Содержание
Хабр (habr.com), 29.12.2022 15:05, SLY_G, Что такое ретроградный Меркурий и почему он никак не влияет на вашу судьбу
Хабр (habr.com), 09.01.2023 12:20, david-shiko, Советы по архитектуре кода для начинающих
Naked Science (naked-science.ru), 17.09.2020 10:28, Александр Березин, Жизнь на Венере и разворот «Роскосмоса»: действительно ли фосфин говорит о населенности ближайшей планеты и почему Россия решила резко активизировать свои венерианские планы?
Хабр (habr.com), 09.01.2023 13:02, Kur_up, Быстрый приём платежей QIWI в проекте Python
Тасс (tass.ru), 28.12.2022 10:08, SpaceX вывела в космос еще 54 мини-спутника для Starlink
Тасс (tass.ru), 29.12.2022 06:10, Китай успешно запустил экспериментальный спутник Shiyan-10-02
Тасс (tass.ru), 30.12.2022 07:47, SpaceX запустила ракету с израильским спутником дистанционного зондирования Земли
Тасс (tass.ru), 03.01.2023 15:05, SpaceX запустила ракету-носитель с коммерческими спутниками
Тасс (tass.ru), 09.01.2023 02:13, Китай успешно вывел на орбиту три исследовательских спутника серии Shiyan
Тасс (tass.ru), 09.01.2023 07:04, Китай успешно запустил пять спутников при помощи ракеты частной разработки "Церера-1"
Тасс (tass.ru), 31.12.2022 09:05, Двигатель для ракеты "Союз-5" прошел первое длительное огневое испытание
Naked Science (naked-science.ru), 01.02.2021 13:21, Сергей Васильев, Толстая литосфера Венеры вряд ли способна к тектонике плит
Naked Science (naked-science.ru), 31.12.2022 15:03, Анна Новиковская, Астрономы обнаружили ключевое сходство между Венерой и Землей
Naked Science (naked-science.ru), 17.09.2020 10:28, Александр Березин, Жизнь на Венере и разворот «Роскосмоса»: действительно ли фосфин говорит о населенности ближайшей планеты и почему Россия решила резко активизировать свои венерианские планы?
Naked Science (naked-science.ru), 26.03.2018 06:03, Редакция Naked Science, Литосфера Венеры оказалась «промежуточным вариантом» между Марсом и Землей
Хабр (habr.com), 17.12.2022 14:29, Vin_Z, «Чтение — всему голова!» Переводим электронные книги формата .EPUB с помощью Python
Хабр (habr.com), 30.12.2022 11:46, Keithla, Пишем FastAPI с нуля на python
Хабр (habr.com), 29.12.2022 22:24, OlegSivchenko, Тринитит — стеклянные слёзы атомного века
Хабр (habr.com), 02.01.2023 14:50, lawxls, Лучшие open-source инструменты для Python проектов

Полные тексты

###

Хабр (habr.com), 29.12.2022 15:05, SLY_G, Что такое ретроградный Меркурий и почему он никак не влияет на вашу судьбу
Теги: меркурий, ретроградный меркурий, астрология
https://habr.com/ru/post/708508/
Одной из величайших загадок XVI века был вопрос с видимым ретроградным движением планет. Объяснения давали как геоцентрическая модель Птолемея (https://ru.wikipedia.org/wiki/Геоцентрическая_система_мира) (слева), так и гелиоцентрическая модель Коперника (https://ru.wikipedia.org/wiki/Гелиоцентрическая_система_мира) (справа). Однако для полного уточнения этого вопроса потребовались теоретические прорывы в понимании законов, лежащих в основе наблюдаемых явлений. В итоге Кеплер открыл свои законы (https://ru.wikipedia.org/wiki/Законы_Кеплера), а Ньютон описал закон всемирного тяготения (https://ru.wikipedia.org/wiki/Классическая_теория_тяготения_Ньютона).

Меркурий становится ретроградным – то есть, меняет направление своего движения по небесной сфере – 3-4 раза в год. Последний раз он проделал это 9 сентября 2022 года. Такое его поведение известно с античных времён, и сначала его неправильно объясняли через теорию эпициклов от Птолемея. Сегодня же мы лучше понимаем гравитацию и то, как объекты двигаются в рамках Солнечной системы. Почему же именно Меркурий ведёт себя так?

Практически весь год наблюдатель на Земле может видеть движение планет по небу, и происходит оно довольно предсказуемо. Если звёзды для наблюдателя остаются неподвижными относительно друг друга, то планеты – будучи гораздо ближе к нам, чем звёзды – ночь от ночи сдвигаются на небе. Большую часть времени эти далёкие миры медленно двигаются в одну и ту же сторону – обычно с запада на восток, причём каждый день их восход и закат происходит всё позже и позже.

Но иногда, если вы будете отслеживать движение каждой из планет постоянно и долго, несколько недель или месяцев, вы заметите, что планета начнёт двигаться медленнее, а потом вообще остановится. После этого на несколько недель она поменяет направление своего движения – это будет т.н. ретроградный период. Наконец это движение вновь замедлится, его направление снова поменяется, и планета снова пойдёт в ту сторону, куда двигалась до этого. Ретроградные периоды обладают своими особенностями для каждой из планет, при этом у Меркурия они самые короткие и самые частые.

Когда большинство планет Солнечной системы входят в ретроградный период – включая Марс, Юпитер, Сатурн, Уран и Нептун – это происходит потому, что Земля «нагоняет» их на орбитах. У орбиты каждой из планет, движущихся вокруг Солнца, есть свои особенности – среднее расстояние до светила и средняя орбитальная скорость. Быстрее всего движутся самые близкие к Солнцу планеты, а медленнее – самые далёкие.

Земля находится на среднем расстоянии в 150 млн км от Солнца и большую часть года движется по орбите со скоростью 30 км/с. Меркурий и Венера расположены ближе и двигаются быстрее. Среднее расстояние от Меркурия до Солнца – 58 млн км, скорость – 47 км/с. Все внешние планеты расположены дальше и двигаются медленнее. Нептун расположен на расстоянии в 4,5 млрд км и движется со скоростью в 5 км/с. На полный оборот по орбите у Нептуна уходит более 160 земных лет. Меркурий же успевает более четырёх раз пробежать вокруг Солнца, пока Земля делает один оборот.

Одной из наиболее гениальных геометрических идей истории было осознание того, что для возникновения ретроградного движения, наблюдаемого с Земли, планете вовсе не нужно физически менять траекторию движения, его скорость или направление. Всё это можно объяснить при помощи простой гелиоцентрической модели. Возьмём для примера Землю и Марс. Марс находится дальше от Солнца и медленнее движется по орбите. Соответственно, Земля совершает один оборот за меньшее время. В итоге, когда Земля проходит между Солнцем и Марсом, она его «обгоняет».

Обгон планеты для нас будет выглядеть так же, как обгон на шоссе автомобиля – с нашей точки зрения планета будет двигаться «назад», хотя на самом деле все мы движемся вперёд, просто другая планета делает это медленнее. Поскольку Земля двигается по космосу быстрее Марса и примерно в том же направлении, кажется, что Марс меняет нормальное направление движения с запада на восток на противоположное, и начинает двигаться с востока на запад относительно неподвижных звёзд. И только после пары месяцев ретроградного движения Марс возобновляет привычное перемещение, когда Земля движется по примерно перпендикулярному вектору.

Подобная схема работает для всех внешних планет. Чем дальше планета, тем сильнее эффект. Если скорость движения Марса сравнима с Земной, то Сатурн, Уран и Нептун движутся гораздо медленнее, поэтому их движение по нашей небесной сфере почти полностью определяется тем, как Земля движется по Солнечной системе. Каждый раз, когда Земля проходит между более удалённой планетой и Солнцем, видимое движение этой планеты по нашему небосводу меняется с обычного (с запада на восток) на ретроградное (с востока на запад). Потом в какой-то момент, когда Земля, пройдя по орбите, начинает двигаться в другом направлении, внешняя планета вновь начинает обычное движение по небу.

Со внутренними планетами, Венерой и Меркурием, всё происходит наоборот. Они двигаются по орбитам быстрее Земли, а их орбиты меньше нашей. Большую часть времени Меркурий и Венера двигаются с востока на запад, постепенно превращаясь из утренних звёзд (видимых в небе до рассвета) в вечерние (видимые после заката).



Симуляция движения планет Солнечной системы за один земной год. Видно, как Меркурий перегоняет Землю на орбите три раза за год. Период обращения Меркурия составляет всего 88 дней, поэтому у него бывает 3-4 ретроградных периода за год – это единственная планета, у которой таких периодов в год больше одного. Другие планеты начинают ретроградное движение только когда их обгоняет Земля – примерно раз в год для всех планет, кроме Марса, у которого это бывает реже.

Однако в какой-то определённый момент – в последний раз с Меркурием такое случилось 9 сентября 2022 года – внутренняя планета входит в период максимальной элонгации в небе после заката, когда она находится в дальней от Солнца точке, к западу от него. Через непродолжительное время, в данном случае – пару недель, внутренняя планета переходит на ретроградное движение, с запада на восток. Только у Венеры и Меркурия ретроградное движение связано с перемещением по небу с запада на восток.

Эти ретроградные периоды соответствуют той части орбит Венеры и Меркурия, где эти внутренние планеты движутся между Солнцем и Землёй, и обгоняют нас. Случается это тогда, когда у внутренней планеты компонент скорости, направленной в ту же сторону, что и наша скорость, оказывается выше, чем у Земли, и длится это всего несколько недель. Меркурий начал свой ретроградный период 9 сентября и закончил 1 октября.

Когда внутренняя планета обгоняет Землю, она начинает «заворачивать», обходя Солнце вокруг, и ретроградный период заканчивается, когда её компонента скорости по направлению движения Земли становится меньше, чем у Земли. При этом элонгация планеты будет ещё какое-то время увеличиваться. Хотя ретроградный период Меркурия начался 9 сентября, максимальной элонгации он достиг 27 августа. И наоборот, хотя его ретроградный период закончился 1 октября, максимальной восточной элонгации, видимой в утреннем небе, он достиг 8 октября.

У Меркурия, который завершает полный оборот вокруг Солнца всего за 88 дней (примерно за четверть земного года), часто и регулярно случаются другие ретроградные периоды. Следующий ретроградный период Меркурия начнётся в январе 2023 года, потом в мае, потом в сентябре и потом в декабре 2023. В любой год обычно укладываются 3-4 ретроградных периода Меркурия – у других планет такое случается обычно только по разу в год, а у Марса иногда и реже.

Для любой планеты, движущейся ретроградно, наступает момент, когда Солнце, Земля и эта планета находятся на одной прямой. Этот момент называется нижним соединением – когда внутренняя планета проходит ровно через линию, соединяющую Землю и Солнце. Поскольку плоскости орбит разных планет немного различаются, идеальные соединения происходят довольно редко. Однако такое бывает, мы можем наблюдать такое замечательное явление, как транзит планеты по диску Солнца с точки зрения Земли.

Будущие нижние соединения Меркурия ожидаются 7 января, 1 мая, 6 сентября и 22 декабря 2023 года. Но транзитов по диску Солнца там не будет. Последний транзит Меркурия был 11 ноября 2019 года, а следующий будет только в 2032 году. Из-за того, что Меркурий расположен близко к Солнцу, быстро движется по орбите, а плоскость его орбиты не сильно отличается от нашей, транзиты Меркурия случаются чаще, чем транзиты Венеры.

Венера находится почти в два раза дальше от Солнца, чем Меркурий, плоскость её орбиты наклонена сильнее, а нижнее соединение с Землёй у неё происходит раз в 19 месяцев — а не раз в 3-4 месяца, как у Меркурия. 

Одно из прохождений Венеры случилось 6 июня 1761 года, и поскольку оно было вычислено заранее, за ним наблюдали десятки учёных XVIII века, среди которых был и Михаил Васильевич Ломоносов. Наблюдая за эффектами, видимыми во время прохождения, Ломоносов увидел некое размытие контуров планеты и верно истолковал его, как следствие преломления солнечного света в атмосфере Венеры, не уступающей по величине атмосфере Земли. Впоследствии эффект был назван «явлением Ломоносова (https://ru.wikipedia.org/wiki/Явление_Ломоносова)».

В наше время последний транзит Венеры по диску Солнца случился с 5 на 6 июня 2012 года, а следующий ожидается лишь с 10 на 11 декабря 2117! Средний человек может увидеть лишь два транзита Венеры за всю жизнь, и если вы пропустили транзиты 2004 и 2012 года, вам придётся очень хорошо следить за своим здоровьем, чтобы дожить до следующего.

Во время своих ретроградных периодов Меркурий подходит к Земле ближе всего, и соответственно гравитационно воздействует на неё сильнее, чем в другие периоды. Во время следующего нижнего соединения Меркурий подойдёт на 96 млн км к Земле, однако некоторые соединения могут сокращать это расстояние до минимальных 82 млн км – последний раз такое было в 2015-м. Кроме того, хотя Меркурий и является самой малой планетой Солнечной системы, он может иметь видимый размер в 10 угловых секунд, т.е. в 1/6 угловой минуты (угловая минута составляет 1/60 градуса).

Это всё очень интересно, однако влияние Меркурия на Землю во время ретроградного движения и даже во время нижнего соединения практически невозможно засечь. Как Земля вызывает прецессию орбиты Меркурия, так и Меркурий вызывает прецессию орбиты Земли. К сожалению (или к счастью) эта прецессия меняет орбиту меньше, чем на одну угловую секунду в год, что практически невозможно заметить. Засветки неба Меркурий тоже никакой не даёт, а приливное действие Меркурия меньше, чем у Луны в миллион раз. Так что Меркурий, будь он ретроградным или каким-либо ещё, практически никак не может повлиять на жизнь на Земле – по крайней мере, так, как мы можем измерить.

Однако явление это интересное и абсолютно реальное. Из всех планет Солнечной системы лишь Меркурий становится ретроградным по нескольку раз в год, и обычно это бывает 3-4 раза. Внутренние планеты обычно движутся в небе Земли с востока на запад, а внешние – с запада на восток. В ретроградные периоды всё наоборот – Марс, Юпитер, Сатурн, Уран и Нептун движутся с востока на запад, а Меркурий с запада на восток.

Большинство людей, говоря о ретроградном Меркурии, подразумевают астрологию – они интересуются и беспокоятся о том, как это может повлиять на их жизнь на Земле. Неизвестно, является ли подобное воспринимаемое людьми влияние чем-то большим, чем просто склонностью наблюдателя к подтверждению своей точки зрения, однако астрофизика позволяет нам чётко описать влияние планеты на нашу жизнь – визуально, гравитационно и в связи с приливами. И это влияние практически неразличимо. Но по крайней мере, если теперь вы увидите ретроградное движение Меркурия в ночном небе, вы будете точно знать, отчего это происходит.
Ссылки:
https://ru.wikipedia.org/wiki/Геоцентрическая_система_мира
https://ru.wikipedia.org/wiki/Гелиоцентрическая_система_мира
https://ru.wikipedia.org/wiki/Законы_Кеплера
https://ru.wikipedia.org/wiki/Классическая_теория_тяготения_Ньютона
https://ru.wikipedia.org/wiki/Явление_Ломоносова

###

Хабр (habr.com), 09.01.2023 12:20, david-shiko, Советы по архитектуре кода для начинающих
Теги: Python, oop, clean architecture, clean code
https://habr.com/ru/post/709670/
Для кого статья

Вы уже написали свои первые 1000 строк кода и сейчас хотите сделать их понятнее, потому что внесение изменений занимает столько-же времени, сколько написать заново, но советы из ООП, SOLID, clean architecture и т.д. непонятны вам.

О чем статья

Эта статья - не объяснение принципов ООП, SOLID своими словами, а попытка создать промежуточный уровень между никакой и чистой архитектурами. 100% советы будут накладываться друг на друга и перефразировать SOLID, но так даже лучше.

От кого статья

Я обычный разработчик. Конечно, не гуру разработки, но кому, как не мне, помнить о проблемах, с которыми сталкивался когда только начинал свой путь.

Отказ от ответственности

Уверен, каждый пункт из статьи может быть предметом спора, но на то это и вольный пересказ. Вся статья идет под эмблемой "Лучше применить такую архитектуру, чем не применять вообще никакой".
Формат статьи - наводящие советы / вопросы.
Содержание:

* К чему относится функция.
* Как вы будете модернизировать одну функцию, не затрагивая другую.
* На сколько логических частей я могу раздробить мою функцию?
* Повторяющиеся слова в названиях функций / переменных.
* Что является центральными объектами вашего кода.
* На какие аналогичные функции может быть заменена ваша функция?
* Как выглядит идеальный псевдокод вашей функции?
* Обращайте внимание на формат данных.
* Отдавайте предпочтение пространству имен, а не ветвлениям.
* Скрывайте постоянные аргументы функции внутри отдельной функции.

Совет номер 1

Когда пишете код и не знаете как его организовать - задайте себе вопрос следующего типа:
“К чему относится моя функция?” / “К чему относится этот функционал?” / “За что отвечает этот функционал?” 
Попробуйте мысленно проставить хэштеги вашей функции: 
#обработка, #валидация, #проверка, #БД, #отображение.
Безусловно, запрос к БД может являться частью обработки, но он же в будущем может использоваться и для другой функции,
даже если пока написан только для этой.
Ремарка: Вообще в разработке уже есть устоявщийся набор таких тегов, некоторые из них: validate, check, get, set, show, load, send. Сюда же входит CRUD и HTTP заголовки.

Совет номер 2

Подумайте, что может быть причиной модернизации вашей функции, что заставит ее измениться.
Небольшие изменения не должны существенно затрагивать другие функции.
Например, вам нужно поменять у функции чтения контактов запрос к базе данных,
это не должна быть та-же функция, что и отправка или отображение контактов.
Стремитесь к ситуации, когда добавление нового функционала сводится к созданию нового метода у класса, и возможно, появлению пары новых аргументов у функции / цепочки вызова функций.
Бывают задачи, которые требуют значительных изменений, но это происходит редко.

Совет номер 3

“На какие части я бы разделил этот функционал?”, “На какие еще подфункции можно разделить код этой функции?”.
Рекурсивно задавая себе этот вопрос, вы придете к моменту, когда функция становится "атомарной", ее функционал логически больше не имеет смысла дробить (не путать с атомарной операцией).
def get_product_price():
    …  # Здесь код
Даже ничего не зная об этой функции и требованиях к задаче, я предполагаю,
 что процесс вычисления цены можно разбить на N этапов, к примеру:

* Применить общую формулу процентов. - Та самая атомарная операция.
* Раздробить это действие уже не получится.
* Применить ограничения к цене.
* Товар не может стоить меньше, чем похожий товар из прошлогодней коллекции и т.п.
* Применить скидку. Скидка не может быть отрицательной, больше 100%, и т.п.

Две функции ниже могут быть общими для всего проекта и находиться в модуле "util.py (http://util.py)".
Классы могут использовать эти функции под разными и аргументами, делая обертку вокруг них.
Примечание: не все программисты одобряют такой модуль в проекте, я встречал статью с критикой такого подхода, но на этом этапе это вполне оправдано.

# (Не очень удачное название)
def calculate_percentage_number(number: int, percentage: int) -> int:
    return number * (percentage / 100)

def limit_number(number: int, min_: int, max_: int, ) -> int:
    """Вернет число или ограничение числа."""
    return min(max(min_, number), max_)

def get_product_price(price: int, discount: int, ) -> int:
    min_discount = 10  # Лучше поместить внутрь класса    
    max_discount = 20  # Лучше поместить внутрь класса
    discount = calculate_percentage_number(number=price, percentage=discount, )
    discount = limit_number(
        number=discount,
        min_=min_discount,
        max_=max_discount,
    )
    discounted_price = price - discount
    if 0 < discounted_price < price:
        return discounted_price
    # Игнорируем скидку в случае ошибки. 
    logger.log(DiscountError)
    return price  # Более разумным будет применить базовую скидку.

Обратите внимание как меняются имена переменных в зависимости от контекста, 
price -> number, discount -> percentage.
Подсказка: Если функцию без труда можно записать в функциональном стиле
(когда наша функция в качества аргумента вызывает другую функцию) - то к ней применимо правило дробления.
Разумеется, не нужно сразу дробить ваш функционал на 1000 частей, далеко не все вам понадобится (принцип YAGNI), но вы должно быть к этому готовым.
Подсказка: Для процентов можно создать отдельный тип, что бы не путать с обычными числами.

Совет номер 4

Обратите внимание на повторяющиеся "user" в названии функций.

def get_user_data():    
    ...

def notify_user_friends():    
    ...

def create_user_post():    
    ...

Такие повторения явный признак, что пора создавать класс для повторяющегося слова:
В пайтоне класс это не только объект, который должен быть создан много раз, но и пространство имен (удобная организация функций).
Ремарка: Лично я считаю, что инструкция "class" в пайтоне перегружена,
 это и пространство имен, и структура данных, и сами классы собственно.
Лучше будет:

class User():
    def get_data():
        ...

    def notify_friends():
        ...

Совет номер 5

ООП вращается вокруг объектов / сущностей / моделей, которые определяет бизнес / работодатель.
В проекте условного мессенджера класс "сообщение" будет большим,
а в проекте про такси класс "сообщение" будет куда меньше, зато будет большой класс "автомобиль".
Определите для себя, какие классы в вашем проекте центральные и наполняйте их методами.
Ремарка: возможно в ближайшем будущем какой-нибудь ИИ создаст универсальную структуру для каждого объекта на земле и в каждом проекте будут одинаковые объекты, но скорее всего ИИ просто научится программировать лучше нас, без всякой организации кода :)
На моей практике начало любого проекта это небольшой набор стандартных функций и классов, например:
View, DB, User, Mail. Они используются для общих целей.
Очень быстро в сервисе такси класс Taxi перерастет остальные классы и будет иметь собственный метод приветствия.

def some_func(user: User):
    ...
    View.say_hello(name=user.name, )  # Общее приветствие.
    taxi.say_hello(name=user.name, )  # Приветствие от конкретного такси.
    ...

Это может выглядеть подозрительно, но преимуществ у такого подхода больше чем недостатков.
Общий метод say_hello помещается в общий класс View, 
а вот taxi_say_hello в класс Taxi.
Это не самое гибкое решение, но на практике такого подхода должно хватать надолго для не крупных проектов.
Ремарка: насколько я знаю, подход MVC (Model-View-Controller) имеет как сторонников, так и противников.
Поэтому в первую очередь все должно зависеть от требований к проекту.

Совет номер 6

На что я МОГУ заменить свою функцию / класс?
Допустим, у вас есть класс user и у него есть метод отправки данных по почте.
Для этого вы используете какой-либо фреймворк.
В какой-то момент вы решили сменить этот фреймворк.
Старый фреймворк:

recipient = BarMailAgent.serialize_recipient(recipient=...) 
FooMailAgent.send(text=self.get_txt_data(), recipient=..., retry=3, delay=10)

Новый фреймворк:

# recipient serialization already inside the method
BarMailAgent.send(message=self.get_txt_data(), email=..., attempts=3, interval=10)

FooMailAgent1 и BarMailAgent делают примерно одно и тоже, но быстро заменить в коде одно на другое не получится, разные аргументы, разный набор действий.
Лучше создать универсальный класс / метод именно для вашего кода (учитывая специфику), который будет принимать заранее известные аргументы, а дальше уже передавать их какому-либо методу.

class User:
    def send_email(self, version: int = 1, arguments=...):
        if version == 1:
            recipient = BarMailAgent.serialize_recipient(recipient=...)
            FooMailAgent.send(text=self.get_txt_data(), recipient=..., retry=3, delay=10)
        else:
            # recipient serialization already inside the method
            BarMailAgent.send(message=self.get_txt_data(), email=..., attempts=3, interval=10)

Совсем безболезненно заменить фреймворк трудно, но это явно облегчит задачу.

Совет номер 7

Напишите сперва идеальный псевдокод, как в идеальном случае должен выглядеть ваш код, пример:

def register(user: User):
    user.validate()
    user.save()
    logger.log(event=events.registration, entity=user, )
    mail.send(event=events.registration, recipient=user.email, )
    notifier.notify(event=events.registration, recipients=user.possible_friends, )
    statistics.add_record(event=events.registration, recipient=user.email,)

Ремарка: Я пользуюсь правилом: 1 строчка - 1 действие.
Это сделано для того, что бы можно было быстро пробежаться глазами.
Когда  кода много - основная причина ошибок это невнимательность, и хорошо, если тесты покроют этот случай.
Можно запросто забыть оправить почту, уведомить друзей и т.п., особенно, когда набор действий постоянно меняется от руководства и команды аналитики.
Где-то снаружи код может выглядеть так:

def register_handler(update, context):
    try:
        events.register(user=context.user)
    except Exceptions.Registration.ValidationError:
        # Где-то внутри будет: "400. Увы, вы ввели некорректные данные, мы не можем сохранить такого пользователя."
        events.fails.registration(user=user)
    except Exceptions.Registration.DbError:
        # Где-то внутри будет: "503. Внутренняя ошибка, приносим свои извинения."
        events.fails.registration(user=user)

Должен отметить, что этот код вызывает у меня самого несколько некритичных сомнений:

* Должен ли блок
* try/except
* быть снаружи метода "
* register
* "?
* Можно ли упаковать "
* user
* " в "
* events.registration
* "?
* Нужно ли передавать целиком пользователя или только необходимые атрибуты?
* С 1-ой стороны это делает код очевиднее, с другой - при изменении необходимого набора - придется больше писать.
* Я для себя пришел к такому компромиссу:
* Если атрибут неотъемлемая часть объекта (почта, телефон, айди) - передаем объект целиком, иначе - только атрибут.

В любом случае, это неплохой вариант для архитектуры.

Совет номер 8

Обращайте внимание на формат данных.
Какой-нибудь фреймворк может передавать на вход вашим обработчикам объект под названием event / update.
Функции проверки из этого объекта нужен только атрибут "user",
а базе данных из этого объекта нужен только атрибут "ID" или "role".
Т.е. условная проверка прав доступа может выглядеть так:
update / event - передано в обработчик.
update.user - передано в функцию проверки.
user.id - передано в запрос к базе данных.
Не нужно в функцию проверки передавать update целиком, таким образом ваша функция обработки сможет быть использована сразу для нескольких фреймворков. Именно это позволяет мне легко сменить мой фреймворк при желании.
Мои функции валидации / проверки не зависят от формата данных предоставленных фреймворком.

Совет номер 9

Отдавайте предпочтение пространству имен, а не ветвлениям.
Каждая ветка if/else усложняет код, создает потенциальную возможность ошибки и усложняет тестирование.
Ремарка: в архитектуре существуют метрики сложности кода, чрезмерное ветвление ухудшает показатели.
Теоретически, все API можно написать на ветвлениях, но не нужно:

def gloabal_handler(request):
    if request.url == 'settings':
        ...
    elif request.url == 'photos':
        ...

Отдавайте ветвления на откуп ЯП, ведь в конечном счете пространство имен можно представить как:

for key in namespace:
    if key == dot_value:
        return key

Ремарка: Лично я, кроме обычного кейсов, использую компромиссный подход, применяю ветвление если от него зависят аргументы функции, но не сама функция (и не будет зависеть в будущем).
(функцию тоже можно представить как аргумент, но это часто может усложнить код, оставьте это для декораторов).

Совет номер 10

Скрывайте постоянные аргументы функции внутри отдельной функции.
Здесь аргумент 'hello' всегда одинаковый, он не несет никакой полезной нагрузки при анализе кода, в 9 / 10 случаях при чтении кода мы НЕ хотим концентрировать свое внимание на том, какой текст отправляется, но код ниже заставляет нас это делать.
Легко читаемая функция, но может быть еще проще.

# Используйте переменную-константу вместо 'hello'
bot.send_message(text='hello', recipient=user.id, )

Краткость - сестра таланта.

View.say_hello(recipient=recipient, ) # bot.send_message внутри

Благодарю за внимание.
Ссылки:
http://util.py

###

Naked Science (naked-science.ru), 17.09.2020 10:28, Александр Березин, Жизнь на Венере и разворот «Роскосмоса»: действительно ли фосфин говорит о населенности ближайшей планеты и почему Россия решила резко активизировать свои венерианские планы?
Теги: Астрономия, Венера, внеземная жизнь, космонавтика, космос, Роскосмос, Выбор редакции
Аннотация: ​​Недавнее открытие биомаркера фосфина в атмосфере Венеры породило немало споров — есть ли там жизнь? С этим пока не все ясно. Но определенно ясно то, что «Роскосмос» учится использовать хайп в целях пиара: госкорпорация уже предложила взять пробу вещества этой планеты. Для этого она откажется от совместного с NASA проекта «Венера-Д» («Д» — значит «Долгоживущая») и заменит его «своим». Но есть ли повод для такой спешки? О чем на самом деле говорит фосфин в облаках второй планеты? И, главное, справится ли Россия с забором образцов оттуда? Попробуем разобраться.
https://naked-science.ru/article/astronomy/zhizn-na-venere
Что обнаружили

Согласно научной работе, вышедшей (https://www.nature.com/articles/s41550-020-1174-4) в Nature Astronomy, на высотах в 50-60 км на Венере обнаружен фосфин – газ с формулой РН3. Концентрация его была невелика, лишь 20 частей на миллиард, незначительно выше, чем метана на Марсе, но оспорить сам факт  регистрации очень трудно. 
СМИ – в этот раз весьма корректно – отписали, что это очень вероятный признак жизни. Стоит разобраться, почему. Во-первых, фосфин весьма химически активен. В итоге он разлагается при повышенной температуре на чистый фосфор и водород, из атомов которых и состоит. Во-вторых, фосфор после этого в условиях венерианских облаков должен элементарно падать вниз, где никакого водорода, заметим, нет – то есть из мест, где его заметили земные телескопы, фосфин должен постоянно исчезать. В-третьих, что особенно важно, на Земле этот газ до появления людей образовывался только одним способом – в результате деятельности анаэробных бактерий. 
Снимки поверхности Венеры, полученные советскими посадочными аппаратами / ©Роскосмос
К сожалению, газ этот даже на Земле настолько редкий (https://www.sciencedirect.com/science/article/abs/pii/S0960852401000323?via=ihub), что выяснить, какие именно бактерии его производят, сложно. Однако то, что у нас он в основном биогенный – факт, поскольку появляется буквально на каждой свалке или у любой большой кучи навоза. И там, и там бурно размножаются анаэробные микробы (бактерии и, в меньшей степени, археи (https://ru.wikipedia.org/wiki/Археи)), но никакие неорганические процессы, способные породить такое соединение, там не идут.
Возможна ли наработка фосфина небиогенным путем в принципе? Да, безусловно: например, его следы есть в атмосфере Юпитера. Но расчеты показывают, что для его получения без участия живых существ, с их сложными каталитическими процессами, нужно огромное количество энергии. 
В случае Юпитера понятно, откуда она может взяться: фосфин там поднимается из недр планеты, где температуры измеряются тысячами градусов, что позволяет фосфору вступать в реакцию с водородом, весьма распространенном на газовых гигантах. В итоге неизбежно образуется именно фосфин. Но на Венере намного прохладнее, чем в юпитерианских недрах, а главное — в ее атмосфере почти нет свободного водорода. 
Панорамные фото Венеры, сделанные одним из советских спускаемых аппаратов / ©Роскосмос
Чисто теоретически, фосфин на Венере может выбрасываться вулканами (хотя на Земле в заметных масштабах это не происходит). Однако авторы работы в Nature Astronomy корректно замечают, что нужный для этого масштаб извержений должен быть в сотни раз выше земного. И это если исходить из самых оптимистичных оценок живучести фосфина в атмосфере второй планеты. Но на Венере нет следов текущей вулканической активности в сотни раз выше земной. Кроме того, в нижних слоях ее атмосферы фосфин, из-за высокой температуры, должен распадаться в течении часа, то есть почти сразу после извержений.
Из-за всего этого еще в 2019 году исследователи из Массачусетского технологического института (США) в своей работе в журнале Astrobiology предложили (https://www.liebertpub.com/doi/abs/10.1089/ast.2018.1954?journalCode=ast) искать фосфин на экзопланетах земного типа как признак наличия там жизни. Именно по ее следам организовали анализ спектров венерианской атмосферы – и обнаружили там этот газ.

Но как же быть с «адскими условиями на Венере», где «не может быть ничего живого»?

Читатель вправе усомниться. В школе рассказывают, что на Венере +462 °C по Цельсию, то есть теплее точки плавления свинца. А давление в 93 раза выше, чем на поверхности Земли – если туда поместить сосновый кубик, его сожмет в два раза, на Земле такое же давление в 930 метрах под водой.  Какая жизнь может существовать в таких условиях?
Однако никакого парадокса тут нет. Дело в том, что на высоте 50-60 километров Венера, как установили еще советские зонды полвека тому назад, имеет примерно земные температурные условия: например, на 55 километрах там неизменно 21 градус по Цельсию. Днем и ночью, зимой и летом – благо из-за плотности венерианской атмосферы сезонных и суточных колебаний температуры там просто нет. Давление на 55 километрах равно половине земного на уровне моря – или такое же, как у нас на 5,5 километрах. Это вполне приемлемо для земных микробов, и даже некоторые альпинисты, после длительной адаптации, вполне действуют при таком давлении.
Именно из-за примерно земных температур и давления облака Венеры уже очень давно предложили (https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&) как возможную зону колонизации. Дело в том, что, с точки зрения здоровья колонистов, главным ресурсом других планет считают наличие на них приличной гравитации. Иначе нужны или центрифуги для повышенного тяготения во время сна, или смирение перед процессами деградации костной и мышечной ткани живущих там людей. Венерианский уровень гравитации – 90,4% от земного, и в этом плане лучшего объекта для колонизации в этой системе нам не найти.
Колония на Марсе к 2050 году: построит ли Илон Маск город на Красной планете
SpaceX рассчитывает к 2050 году создать на Марсе колонию на миллион человек. Звучит абсурдно: осталось всего 30 лет, а до первого полета на Марс еще многие годы. Некоторые ученые, включая российски...
naked-science.ru
(https://naked-science.ru/article/cosmonautics/koloniya-na-marse-postroit-li-ilon-mask-gorod-na-krasnoj-planete?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle)
При этом, в отличие от Марса, на высоте 55 километров колонистам не потребуются ни подогрев, ни охлаждение: достаточно будет поддерживать аэростаты с их «воздухоплавательными« городами на одной и той же высоте. Уровень солнечного освещения на 55 километрах даже чуть выше земного, то есть в прозрачных галереях на «спине» гигантских дирижаблей вполне можно будет выращивать земные растения. На высоте 100 километров там есть (https://www.sciencedirect.com/science/article/abs/pii/S0019103511003277) озоновый слой, хотя и много тоньше земного. 
Конечно, на 55 километрах уровень ультрафиолета выше «нашей» нормы, но обычное стекло легко блокирует его до значений ниже земных. Хотя серьезного магнитного поля у второй планеты нет, уровень космической радиации там довольно низок: ведь атмосфера, как и на Земле, эффективно поглощает космические лучи. В общем, как отмечает (https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus) Джеффри Лэндис из NASA: «Атмосфера Венеры – самая землеподобная среда в Солнечной системе (после Земли)».
Кстати, когда мы говорим «аэростат», это вовсе не значит, что для такой колонизации потребовались бы специальные легкие газы, которыми наполняют аэростаты на Земле. На самом деле, для этого даже не нужен аэростат в привычном нам смысле слова. 
Дело в том, что обычный земной воздух намного легче венерианского – почти чистого углекислого газа. Поэтому простая гермооболочка, наполненная банальным воздухом, будет плавать в атмосфере Венеры. А при наличии компактного атомного реактора и/или растений в прозрачных галереях колонисты всегда смогут получить кислород из окружающего колонию-аэростат углекислого газа газовой оболочки второй планеты.
Работники NASA констатируют (https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus), что километровая шарообразная гермооболочка на Венере будет иметь подъемную силу в 0,7 миллионов тонн – вполне достаточную, чтобы поддержать немалых размеров поселение. Двухкилометровый шар будет поднимать уже примерно шесть миллионов тонн. 
Остается последнее возражение: венерианские облака содержат капельки серной кислоты. Не разъест ли она конструкции такой колонии? На этот вопрос давным-давно ответили (https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus) советские инженеры. Еще в 1985 году созданные ими аэростаты вполне успешно исследовали облачный слой Венеры, и при этом их оболочка была сделана из тонкого слоя обычнейшего тефлона. 
Макет советского аэростата, который в 1985 году стал первым в истории чисто атмосферным летательным аппаратом, примененным для изучения других планет / ©Wikimedia Commons 
Тогда, впервые в истории землян, два аэростата пару суток подряд смогли исследовать другое небесное тело, проделав над ним путь в одиннадцать тысяч километров, прежде чем опустились (следуя плану) на поверхность планеты. В процессе они заметно уточнили наши представления об облачном слое планеты, а также открыли наличие на Венере сильных гроз.
Кстати, на сегодня – спустя 45 лет – человечество так и не смогло повторить советское достижение. Ни разу с 1980-х годов летательным аппаратом аэростатного, самолетного или вертолетного типа так и не удалось исследовать другую планету. Лишь в ближайшие годы миниатюрный дрон американского марсохода сможет начать экспериментальное трехминутные полеты на Марсе.
По сути дела, советские миссии показали, что любой человек в тефлоновом костюме с кислородным аппаратом может (https://www.scientificamerican.com/article/venus-ussr-1967-mission/) прогуливаться на поверхности колонии-аэростата безо всякого космического скафандра – а вот на Марсе и Луне, как мы уже писали, нужда в таких скафандрах – очень большая и трудно решаемая проблема.

Откуда там взяться жизни?

Итак, в принципе, фосфин на второй планете действительно может быть продуктом жизнедеятельности анаэробных бактерий – по крайней мере, науке на сегодня неизвестны небиогенные процессы, которые могли бы образовать его там. Но возникает другой вопрос: а откуда на Венере такие микроорганизмы?
Конечно, соблазнительно было бы предположить, что их принесли сами земляне. Целый ряд советских спускаемых аппаратов – да и те же аэростаты – проходили дезинфекцию, которая, как известно сегодня, недостаточна для того, чтобы убить наиболее живучие земные бактерии и археи. Но это достаточно сомнительно: многие анаэробные микробы плохо переносят насыщенный кислородом воздух, поэтому их наличие в сборочных цехах «НПО им. Лавочкина» в советскую эпоху представляется маловероятным.
Есть куда более простое объяснение. В 2016 году выяснилось (https://life.ru/p/887208), что (https://arxiv.org/abs/1608.00706) в ранней стадии истории Солнечной системы Венера могла быть существенно более пригодной для возникновения жизни, чем Земля. Ведь сутки на второй планете нашей системы в 243 раза длиннее нынешних земных – а это крайне мощный охлаждающий фактор планетарного климата. 
Согласно расчетам американских и шведских исследователей, 2-3 миллиарда лет назад Венера могла выглядеть примерно так, то есть иметь глобальный океан, покрывающий основную часть ее поверхности / ©Wikimedia Commons
Длинная ночь означает, что куда большая, чем на Земле, часть тепла, полученного от солнечных лучей, будет переизлучена в космос в виде инфракрасного излучения. То есть хотя Венера и получает почти в полтора раза больше солнечной энергии, чем наша планета, но при земном составе атмосферы она имела бы среднюю температуру, равную нашей.
Более того, 0,7-2,9 миллиарда лет тому назад эта температура должна была быть даже чуть ниже, чем на сегодняшней Земле – примерно как у нас 15 тысяч лет назад, то есть около плюс 11 по Цельсию. По расчетам американских и шведских исследователей, в ту пору океанами и морями было покрыто до 60% поверхности второй планеты, а атмосфера была в основном азотной – как и на ранней Земле. По мнению (https://arxiv.org/abs/1608.00706) некоторых исследователей, нельзя исключать, что именно на Венере впервые в Солнечной системе и возникла жизнь.

Но как она могла там уцелеть?

Как известно, в последние сотни миллионов лет на Венере начались гигантские извержения, выбросившие в атмосферу огромное количество углекислого газа. Он поднял температуру выше плюс 450 по Цельсию, в результате океаны и моря планетой давно потеряны, и ее поверхность больше не пригодна для жизни земного типа. Получается, даже если эта планета и была прародиной жизни в нашей системе, сейчас она должна стать мертвой. Даже относительно благоприятные условия в облачном слое не помогут: ведь жизнь не может витать в облаках сотни миллионов лет подряд. Или все-таки может?
Ответ на этот вопрос в другой публикации попробовала (https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&) получить группа во главе с Сарой Cиджер (Sara Seager), одним из авторов и недавней работы по венерианскому фосфину. Вместе с соавторами она обратилась к итогам исследования тропо- и стратосферы Земли и выяснила, что микробы там есть до высоты в десятки километров, причем вплоть до верхней части тропосферы – где температура и давление куда ниже, чем в венерианских облаках – они сохраняют метаболическую активность. Следов деления у них там не нашли, но надо понимать, что исследовать одноклеточные в таких условиях крайне сложно, поэтому такое деление (размножение) исключать никак нельзя.
Но проблема в том, что облака Венеры состоят в основном из серной кислоты (не менее, чем на 85%). Водяной пар там тоже есть, но в концентрации 40-200 частей на миллион, что исключительно мало. Скажем, на Земле самый сухой воздух в Атакаме – но и там относительная влажность 2%, а в облаках Венеры – 0,07%. В таких условиях вода, в принципе, все равно может концентрироваться в количествах, формально достаточных для выживания – в каплях серной кислоты, составляя примесь, которая не превышает 15%. Кроме того, в этих каплях молекулы воды как бы «привязаны» к молекулам серной кислоты, и поэтому их использование для любой потенциальной местной жизни затруднено.
И тем не менее, отрицать вероятность существования жизни даже в таких условиях нельзя. Во-первых, в облаках Венеры давным-давно нашли сероводород и сернистый газ, которые реагируют друг с другом. И поэтому, строго говоря, не могут существовать без внешней подпитки за счет каких-то необычных химических реакций. Там же найден (https://www.sciencedirect.com/science/article/abs/pii/S0032063399000367?via=ihub) и карбонила сульфид (O=C=S). 
На Земле это соединение – четкий биомаркер, по изменению следов которого в атмосфере исследователи полярных ледовых кернов могут точно определить, как меняется биомасса на нашей планете с течением времени. Кроме того, получить карбонила сульфид не биогенно очень сложно, и до появления промышленности он на планете производился исключительно живыми организмами – в силу наличия у них крайне эффективных катализаторов.
Наконец, отмечает Сиджер с соавторами, на снимках в УФ-диапазоне видно, что в облаках Венеры есть какие-то непонятные образования, поглощающие ультрафиолет – основную его часть, достигающую этого слоя атмосферы. Размеры этих частиц варьируют в микрометровом диапазоне (на нашей планете такие размеры часто имеют бактериальные споры) до еще больших. Это, вкупе с наличием на Земле фотосинтезирующих анаэробных микроорганизмов, использующих (https://ru.wikipedia.org/wiki/Зелёные_серобактерии) вместо углерода серу, в принципе позволяет ожидать, что какие-то возможности для фотосинтеза есть и в венерианских облаках. 
Зеленые серобактерии в земной лаборатории. В отличие от привычных нам фотосинтезирующих организмов, они не дышат кислородом, и нуждаются только в сероводороде, водороде и сере / ©Wikimedia Commons
Ей не сможет помешать относительно высокий ультрафиолет – напротив, на Земле есть живые организмы (грибы Cryptococcus neoformans), использующие ионизирующее коротковолновое излучение как источник энергии. Более того, отмечает Сиджер, на нашей планете такие любители радиации встречаются как в природе (антарктические горы), так и в техногенной среде (компоненты систем охлаждения атомных реакторов, МКС). То есть для многих живых организмов ультрафиолет – не проблема, а источник полезной энергии.
Из всего этого ее группа делает вывод: на Венере возможно существование жизни в облаках, но жизнь это необычная, более напоминающая земной «серный» фотосинтез без доступа к кислороду, нежели что-то еще. Жизненный цикл таких микробов-фотосинтетиков прост: в облачном слое они, за счет гидрофильной оболочки, становятся центром образования капелек из серной кислоты и воды. Затем начинают фотосинтезировать, используя находящийся вокруг них сернистый газ (SO2) и воду. Из их молекул они производят H2SO4 ту самую серную кислоту, из которой, собственно, и состоят в основном местные облака. 
Фосфор, как и, например, железо, – неизбежный участник жизненного цикла самых разных организмов, поэтому в ходе ряда реакций он может, в следовых количествах, выделяться в виде фосфина, который и нашли исследователи с помощью телескопов. 
Кстати, мы не зря упомянули железо: советские аппараты, включая аэростаты, нашли внизу облачного слоя следы хлора. Между тем, как отмечает Сиджер, от поверхности планеты с восходящими потоками поднимает хлорид железа. Если местные микробы используют это железо, они неизбежно должны выбрасывать в окружающую среду какие-то количества свободного хлора.
Жизненный цикл гипотетических венерианских микробов в представлении группы Сиджер. Те, что опускаются ниже облачного слоя, погибают от холода, но их споры с конвекцией в ряде случаев снова вернутся на высоту / ©Wikimedia Commons
Сиджер и соавторы приводят и пример существа, близкого к возможной венерианской жизни – фотосинтезирующего прокариота Prochlorococcus. Это очень небольшой организм, диаметром 0,5-0,7 микрометров, у которого, из-за бедной фосфором среды обитания, внешняя стенка состоит из соединений серы и сахаров. 99% липидов в составе клеточной мембраны у этого организма вместо фосфатных групп включают сульфатные – и сходная адаптация имела бы смысл на Венере, с ее дефицитом фосфора и избытком серы.
Астробиологи описали выживание микробов в атмосфере Венеры
Поверхность Венеры слишком горяча для любой мыслимой жизни, но вот высоко в атмосфере условия не так экстремальны, а восходящие потоки вполне способны удерживать местных микробов от падения вниз.
naked-science.ru
(https://naked-science.ru/article/astronomy/astrobiologi-opisali-vyzhivanie-mikrobov-v-atmosfere-venery?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle)
Капли, в которых находятся такие фотосинтезирующие организмы, нарабатывающие серную кислоту, со временем растут в размерах (за счет окружающих паров серной кислоты и воды) и начинают опускаться вниз. При этом местные организмы должны переходить в фазу производства спор, а затем – погибать. Восходящие потоки неизбежно поднимут часть капель на высоту, где часть спор сможет дать начало новому жизненному циклу в венерианских облаках.
Разумеется, подобная среда будет весьма непростой для выживания. На Земле нет мест, где бактерии или археи могли бы жить в серной кислоте, слегка разбавленной водой. Поэтому мы достоверно не знаем, способны ли они защитить себя от воздействия кислот в таких условиях.  Но и исключать этот сценарий заранее невозможно.

Адекватна ли реакция Роскосмоса? Стоит ли венерианский мираж разрыва отношений с NASA?

Итак, мы установили, что жизнь на Венере, в принципе, возможна. А вот с некоторыми аспектами деятельности разумной жизни на Земле вопросы все еще остаются. 
15 сентября 2020 года на сайте Роскосмоса появилось сообщение (https://www.roscosmos.ru/29217/), реагирующее на открытие фосфина и утверждающее:
«…принято решение о реализации ранее запланированной миссии «Венера-Д», включающей посадочные и орбитальные модули, в качестве независимого национального проекта без широкого привлечения международной кооперации. В рамках комплексных исследований планеты среди прочего будут изучены пробы ее грунта и атмосферы, а также исследована природа эволюционных процессов Венеры, перенесшей ранее, как утверждается, климатическую катастрофу, связанную с парниковым эффектом, о котором сегодня так много говорят применительно к Земле».
Что это? Прекрасно известно, что бюджет Роскосмоса в полдюжины раз меньше, чем у NASA. Так какой смысл отказываться от сотрудничества с Агентством, ранее предусмотренным в составе программы «Венера-Д»? Однако при внимательном взгляде на вопрос причины отказа от кооперации понять становится значительно проще.
Изображения Венеры, полученные в 1975 году советским посадочным аппаратом «Венера-9». Оригинальное изображение вверху, ниже два поправленных в нашу эпоху с помощью алгоритмов заполнения сходным содержимым  / ©Роскосмос
Как отмечает N+1, чей редактор пообщался (https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9) с членами Совета РАН по космосу, еще в июле 2020 года Роскосмос предложил коренным образом пересмотреть миссию «Венера-Д». По пересмотренному варианту, уже в конце 2020-х годов к планете могла полететь посадочная станция с рядом аэростатов, причем станция эта должна была взять с поверхности планеты образец грунта – и затем доставить его на Землю.
Легко видеть, что в международной кооперации такой проект реализовать все равно было нельзя: NASA никогда бы не пошло на это. Начать с того, что забор грунта требует его доставки на Землю, что с поверхности Венеры сделать трудно. Поэтому предложение Роскосмоса предусматривало подъем образца грунта на аэростате в верхние слои атмосферы. Оттуда ракета, поднимаемая аэростатом, должна была вывести образец в космос, где он бы направился к Земле.
Это задачи исключительно высокой сложности и, откровенно говоря, требующие огромной массы посадочного модуля. Речь идет о многих тоннах: как мы уже упоминали, гравитация на Венере – 90% от земной, и возврат грунта оттуда, по этой причине, даже с аэростатом будет крайне энергозатратным. Естественно,  NASA не пошло бы на столь рискованный проект – это не стиль Агентства. 
Возникает вопрос: зачем это Роскосмосу? У России с тех самых советских миссий к Венере не было удачных межпланетных миссий даже с умеренно сложными задачами. Последняя попытка такой миссии утонула в Тихом океане («Фобос-грунт»). Попытка прыгнуть от нуля миссий сразу к миссии такого огромного масштаба и сложности выглядит крайне специфично – попросту говоря, как авантюра с неотработанными средствами исполнения. Неудивительно, что  члены Совета РАН по космосу высказались против (https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9) нее.
Четко понять мотивы руководства Роскосмоса в данном случае сложно. Наиболее вероятных версий две: либо оно не рассчитывает досидеть в своих креслах до конца 2020-х годов и отвечать за риски такого проекта; либо настолько хочет впечатляющих и успешных картинок для публики, что готово даже на такие, говоря языком РАН, «полуфантастические» (https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9) прожекты, лишь бы создать у масс благоприятное впечатление о своей деятельности.
Если верен один из перечисленных случаев – то понять руководство Роскосмоса можно. Всем наблюдателям космической отрасли достаточно очевидно, что в 2020-х годах SpaceX отладит свой сверхтяжелый и самый большой в истории человечества космический носитель Starship. После этого США неизбежно попадут на Луну, а через несколько лет – и на Марс. Годы упорного игнорирования Роскосмосом проектов Маска (в виде нежелания создавать конкурирующие носители для полета на Марс)  исключают для нашей страны отправку туда экспедиций в обозримом будущем. 
На таком фоне нужно срочно объявить какой-то громкий проект, причем степень его реализуемости в обозримые сроки может быть не особенно важна. Ведь ясно, что после начала полетов Starship всю российскую космическую программу придется все равно пересмотреть, «Ангара» мгновенно окажется глубоко устаревшим, и нашей стране переделывать придется все заметные космические проекты вообще. На фоне всего этого за невыполненный проект доставки грунта с Венеры вряд ли кто спросит.
Ссылки:
https://www.nature.com/articles/s41550-020-1174-4
https://www.sciencedirect.com/science/article/abs/pii/S0960852401000323?via=ihub
https://ru.wikipedia.org/wiki/Археи
https://www.liebertpub.com/doi/abs/10.1089/ast.2018.1954?journalCode=ast
https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&
https://naked-science.ru/article/cosmonautics/koloniya-na-marse-postroit-li-ilon-mask-gorod-na-krasnoj-planete?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle
https://www.sciencedirect.com/science/article/abs/pii/S0019103511003277
https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus
https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus
https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus
https://www.scientificamerican.com/article/venus-ussr-1967-mission/
https://life.ru/p/887208
https://arxiv.org/abs/1608.00706
https://arxiv.org/abs/1608.00706
https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&
https://www.sciencedirect.com/science/article/abs/pii/S0032063399000367?via=ihub
https://ru.wikipedia.org/wiki/Зелёные_серобактерии
https://naked-science.ru/article/astronomy/astrobiologi-opisali-vyzhivanie-mikrobov-v-atmosfere-venery?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle
https://www.roscosmos.ru/29217/
https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9
https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9
https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9

###

Хабр (habr.com), 09.01.2023 13:02, Kur_up, Быстрый приём платежей QIWI в проекте Python
Теги: Python, qiwi, оплата, кошелёк, telegram, бот, автоматизация, api
https://habr.com/ru/post/709676/
Необходимость добавить возможность оплаты чего-либо в своём проекте всплывает достаточно часто, при этом возня с ИП, банковскими договорами и прочей бюрократией мало кого привлекает, особенно если масштабы проекта сопоставимы с небольшим telegram-ботом или чем-то подобным. На помощь приходят такие сервисы как QIWI, ЮMoney и другие (не рекламирую, просто нахожу удобным для себя).
Подход прочитать документацию API такого сервиса, написать небольшой модуль и использовать в своих проектах - лучший путь, но начинающие программисты зачастую находят это нудным, сложным и ищут простое готовое решение. Так и я решил когда-то и не нашёл, а теперь вместо переписывания одного модуля по 100 раз решил собрать небольшую библиотеку для быстрой интеграции платежей QIWI.

Установка

В терминале пишем команду и ожидаем конца загрузки:

pip install PyEasyQiwi

Исходный код GitHubhttps://github.com/Kur-up/PyEasyQiwi (https://github.com/Kur-up/PyEasyQiwi)
Пакет PyPihttps://pypi.org/project/PyEasyQiwi/ (https://pypi.org/project/PyEasyQiwi/)

Создание платежа

Для начала импортируем класс для создания соединения с QIWI аккаунтом:

from PyEasyQiwi import QiwiConnection

Конструктор класса принимает один аргумент - ваш секретный API ключ, для начала нам понадобится аккаунт QIWI со статусом "Основной", так как сервис запрещает проводить анонимные платежи. Авторизуемся на сайте:

Далее в верхней панели переходим по вкладкам: Ещё > Приём переводов

Нажимаем "Начать приём платежей" и в верхней панели переходим в создание API ключей

Настраиваем новую пару ключей, дав ей любое название:

На этом этапе копируем и сохраняем ваш секретный ключ (тот что на оранжевом фоне), далее возможности посмотреть его снова не будет. Не забывайте, что секретный ключ даёт доступ к вашему аккаунту без логинов, паролей и прочего, храните его надёжно и не передавайте третьим лицам. В случае если такое произошло, в этом же разделе можно удалить ранее созданные ключи.
Теперь, когда мы получили API ключ, вернёмся к коду.
Создадим подключение указав наш секретный ключ:

api_key = "your_api_key"
conn = QiwiConnection(api_key)

Теперь мы можем использовать экземпляр класса для управления приёмом платежей, начнём с создания счёта на оплату для нашего пользователя, используем метод conn.create_bill()

pay_url, bill_id, response = conn.create_bill(value=1000.00, description="User1")
print(pay_url)

>>> https://oplata.qiwi.com/form/?...

pay_url - строка содержащая ссылку для оплаты (для отправки клиенту или редиректа)bill_id - строка содержащие полное наименование счёта на оплату, состоит из текста указанного в conn.create_bill(..., description="User1") и полной даты создания платежа. (для идентификации каждого отдельно взятого платежа, фактически его ID в вашей базе данных)response - словарь содержащий более подробную информацию о деталях созданного платежа (в некоторых случаях полезно, например для создания подробных логов)
Теперь перейдём по ссылке в pay_url и увидим страницу с формой для оплаты любым удобным из доступных методов:

Так же все операции проведённые через API отобразятся в сервисе:

Конечно, наш метод позволяет более гибко настроить то, что пользователь увидит на данной странице, разберём по порядку все доступные опции:
conn.create_bill(value, currency, delay, description, theme_code, comment, qiwi_pay, card_pay)

* value
* - Обязательный аргумент, сумма для оплаты. Например 100.59. Допустимые значения 1-1000000 (QIWI ограничивает транзакции на сумму более 1000000 рублей).
* currency
* - Валюта для проведения платежа. По умолчанию RUB, доступны варианты "RUB" и "KZT".
* delay
* - Срок действия платежа в минутах. По умолчанию 15 минут. Устанавливает максимальный временной промежуток для оплаты пользователем, после чего закрывает возможность оплаты.
* description
* - Описание платежа, по умолчанию - unknown. Используется для более точной идентификации каждого платежа. Разумно использовать ID пользователя из вашей базы данных.
* theme_code
* - Уникальный код оформления страницы платежа. По умолчанию - пустое значение. Подробнее - далее в статье.
* comment
* - Комментарий который увидит пользователь при оплате. По умолчанию - пустая строка.
* qiwi_pay
* - Возможность оплаты с кошелька QIWI для пользователя. По умолчанию True.
* card_pay
* - Возможность оплаты банковской картой для пользователя. По умолчанию True.


Более полный пример создания платежа

Для начала разберёмся с параметром theme_code:
Этот параметр позволяет задать своё (на сколько это возможно) оформление страницы оплаты, и сервис QIWI предлагает небольшой инструмент для настройки кода персонализации: перейдя по ссылке (https://qiwi.com/p2p-admin/transfers/link) настраиваем всё по своему желанию и сохраняем наш код, позже передадим его в качестве аргумента.

Теперь когда у нас есть всё необходимое попробуем создать новый счёт на оплату, используя всё тот же метод conn.create_bill():

value = 3010.11
currency = "RUB"
delay = 30
description = "test_user_ID"
theme_code = "my_code"
comment = "Привет Хабр!"
qiwi_pay = False
card_pay = True

pay_url, bill_id, response = conn.create_bill(value, currency, delay, description, theme_code, comment, qiwi_pay, card_pay)
print("Ссылка для оплаты: ", pay_url)

>>> https://oplata.qiwi.com/form/?..............

Проверяем, мы отключили оплату с кошелька QIWI, установили код персонализации и добавили комментарий:

Проверка статуса платежа

Вообще, откровенно говоря, сервис умеет присылать ответ на ваш сервер как только один из счетов будет оплачен, но я не успел реализовать это в библиотеке это несёт за собой определённые сложности. Поэтому в данной статье я рассмотрю пример ручной проверки статуса платежа, что в целом - вполне будет решать поставленную задачу не забивая голову болью об обработке ответа на сервер и тд.
В качестве примера возьмём счёт на оплату созданный выше, как вы помните метод conn.create_bill() вернул нам bill_id , он нам и понадобится для отслеживания статуса.

status, response = conn.check_bill(bill_id)
print(status)

>>> WAITING 

status - строка содержащая статус платежа: WAITING - счёт ожидает оплаты, PAID - счёт ожидает оплаты, REJECTED - счёт отклонён, EXPIRED - срок оплаты просрочен (Используется для проверки статуса оплаты)response - словарь с более подробной информацией о счёте
Теперь у нас есть точное понимание, в каком состоянии находится выставленный счёт, как использовать это в своих проектах - решать вам, простейший пример использования:

status, response = conn.check_bill(bill_id)

if status == "PAID":
  # Пользователь оплатил
else:
  # Пользователь не оплатил


Отмена выставленных платежей

Помимо выставления платежей, надо уметь их отменять. Зачем хранить открытым счёт на оплату если пользователь уже сообщил вам (нажав кнопку отмена или например закрыв приложение), потенциально это всегда может привести к неожиданному результату - поэтому хорошей практикой будет закрыть счёт и забыть про него.
Для этого нам всё так же понадобится ID счёта, в нашем случае bill_id и новый метод conn.remove_bill()

conn.remove_bill(bill_id)

Данный метод ничего не возвращает, но если мы попробуем перейти по ссылке для оплаты которую создавали ранее, то увидим следующее:

Так же при проверке статуса платежа будет понятно, что он уже недействителен:

status, response = conn.check_bill(bill_id)
print(status)

>>> REJECTED 

Оплаченный или просроченный счёт закрывать не требуется:

Для ленивых

Небольшой пример для создания платежа со всеми возможными настройками, проверки его статуса, и закрытия этого счёта.
Кодfrom PyEasyQiwi import QiwiConnection

# Создаём подключение
api_key = "your_api_key"
conn = QiwiConnection(api_key)

# Создаём счёт на оплату
value = 500.01
currency = "RUB"
delay = 30
description = "test_user_ID"
theme_code = "my_code"
comment = "PyEasyQiwi"
qiwi_pay = False
card_pay = True

pay_url, bill_id, response = conn.create_bill(value, currency, delay, description, theme_code, comment, qiwi_pay, card_pay)
print("Ссылка для оплаты: ", pay_url)

# Проверяем статус платежа
status, response = conn.check_bill(bill_id)
print("Текущий статус платежа:", status)

# Закрываем счёт на оплату
conn.remove_bill(bill_id)
print("Счёт закрыт!")

Заключение

На этом всё, буду рад если найдёте это полезным для себя. Адекватная критика всегда приветствуется, это мой первый опыт написания статей, так что не судите строго, старался для людей! Ссылки на документацию ниже:
Документацияhttps://developer.qiwi.com/ru/p2p-payments/#p2p- (https://developer.qiwi.com/ru/p2p-payments/#p2p-)
Ссылки:
https://github.com/Kur-up/PyEasyQiwi
https://pypi.org/project/PyEasyQiwi/
https://qiwi.com/p2p-admin/transfers/link
https://developer.qiwi.com/ru/p2p-payments/#p2p-

###

Тасс (tass.ru), 28.12.2022 10:08, SpaceX вывела в космос еще 54 мини-спутника для Starlink
Теги: США
https://tass.ru/kosmos/16704159
НЬЮ-ЙОРК, 28 декабря. /ТАСС/. Компания SpaceX осуществила в среду запуск ракеты-носителя Falcon 9 с 54 мини-спутниками для своей орбитальной интернет-сети Starlink.
"Этот запуск стал 60-м для SpaceX в этом году. Еще один запуск ракеты-носителя Falcon 9 с израильским спутником для съемки земной поверхности состоится на этой неделе с базы ВВС США Ванденберг (штат Калифорния)", - говорится на сайте (https://www.spacex.com/) компании.
Семидесятиметровый двухступенчатый носитель с бортовым номером B1062 стартовал с космодрома на мысе Канаверал (штат Флорида) в 04:34 по местному времени (12:34 мск). Его первая ступень использовалась ранее для 10 других запусков. Ожидается, что примерно через 9 минут после старта она в автоматическом режиме опустится на плавучую платформу, находящуюся в Атлантическом океане у побережья Флориды. Многократное применение ступеней ракет позволяет компании Илона Маска удешевлять стоимость вывода аппаратов на орбиту.
SpaceX заверяет, что Starlink сможет обеспечить доступ в интернет в любой части планеты со скоростью трафика 1 гигабит в секунду, что соответствует стандарту 5G. Компания уже вывела в космос с мая 2019 года, осуществив 60 запусков Falcon 9, 3 612 мини-спутников, 3 200 из них находятся в рабочем состоянии. SpaceX планирует разместить на орбите в общей сложности 11 тыс. спутников, что, по оценкам самой компании, обойдется в 10 млрд долларов. В настоящее время сеть доступна пользователям в Северной Америке, Европе и Австралии.
Ссылки:
https://www.spacex.com/

###

Тасс (tass.ru), 29.12.2022 06:10, Китай успешно запустил экспериментальный спутник Shiyan-10-02
Теги: Китай
https://tass.ru/kosmos/16711129
ПЕКИН, 29 декабря. /ТАСС/. Китай в четверг успешно вывел на орбиту экспериментальный спутник Shiyan-10-02. Об этом сообщила Китайская корпорация аэрокосмической науки и техники.
Как уточняется на ее странице в социальной сети WeChat, запуск был осуществлен в 12:43 по пекинскому времени (07:43 мск) при помощи ракеты CZ-3B ("Чанчжэн-3-бэ") с космодрома Сичан на юго-западе страны. Он стал 458-м для носителей данной серии.
Предполагается, что на этот раз вывод космического аппарата на орбиту был последним для КНР в текущем году. По данным корпорации, в 2022 году осуществлено 54 запуска носителей, разработанных корпорацией. Все они прошли успешно. Всего же Китай в текущем году запустил ракеты более 60 раз, побив собственный прошлогодний рекорд.
Shiyan-10, как отмечается, планируется использовать для испытания на орбите новых технологий.

Пекин активно развивает национальную космическую программу, разрабатывая метеорологические, телекоммуникационные и навигационные спутники, а также технологии для освоения Луны. Китайские специалисты одновременно реализуют проект по исследованию астероидов и Марса. На орбите завершено строительство космической станции КНР, которая вскоре должна заработать в штатном режиме.
В 2021 году Китай осуществил 55 космических запусков, поставив национальный рекорд. По данному показателю КНР обошла США, заняв первое место в мире.


###

Тасс (tass.ru), 30.12.2022 07:47, SpaceX запустила ракету с израильским спутником дистанционного зондирования Земли
Теги: США, Израиль
https://tass.ru/kosmos/16719923
НЬЮ-ЙОРК, 30 декабря. /ТАСС/. Компания SpaceX осуществила в четверг запуск ракеты-носителя с израильским спутником дистанционного зондирования Земли EROS-C3. Трансляция ведется на сайте компании.
Старт ракеты состоялся с базы ВВС США Ванденберг (штат Калифорния) в 23:38 по местному времени (10:38 мск 30 декабря), он станет последним для SpaceX в этом году, всего компания осуществила 61 запуск за 2022 год.
Первая ступень ракеты-носителя ранее использовалась в 10 запусках. Сотрудники SpaceX намерены вернуть этот элемент Falcon 9 на Землю.
В начале XXI века два запуска спутников EROS осуществляла Россия с помощью ракеты-носителя "Старт-1". Запуски осуществлялись с космодрома Свободный.


###

Тасс (tass.ru), 03.01.2023 15:05, SpaceX запустила ракету-носитель с коммерческими спутниками
Теги: США
https://tass.ru/kosmos/16737709
НЬЮ-ЙОРК, 3 января. /ТАСС/. Американская компания SpaceX осуществила во вторник запуск ракеты-носителя Falcon 9, которая выведет на орбиту 114 коммерческих аппаратов. Трансляция запуска ведется на сайте (https://www.spacex.com/) компании.
Запуск ракеты в рамках миссии Transporter-6 состоялся с космодрома на мысе Канаверал (штат Флорида) в 09:56 по местному времени (17:56 мск). Falcon 9 доставит на околоземную орбиту 114 микроспутников и других аппаратов, их развертывание начнется примерно через час после запуска.
Первая ступень ракеты-носителя ранее использовалась в 14 запусках. Сотрудники SpaceX намерены вернуть этот элемент Falcon 9 на Землю. Ожидается, что после старта ступень в автоматическом режиме плавно опустится на площадку, расположенную на космодроме. Эта технология позволяет компании снижать стоимость очередных запусков.
Ссылки:
https://www.spacex.com/

###

Тасс (tass.ru), 09.01.2023 02:13, Китай успешно вывел на орбиту три исследовательских спутника серии Shiyan
Теги: Китай
https://tass.ru/kosmos/16756537
ПЕКИН, 9 января. /ТАСС/. Китай при помощи ракеты-носителя "Чанчжэн-7" (CZ-7, англоязычное название Long March-7) успешно вывел в воскресенье на орбиту три исследовательских спутника серии Shiyan. Об этом сообщило Центральное телевидение Китая (https://tv.cctv.com/cctvrussian).
Запуск состоялся в 06:00 по местному времени (01:00 мск) с космодрома Вэньчан (провинция Хайнань). Как отмечает телеканал, спутниковые аппараты Shiyan-23, Shiyan-22-a и Shiyan-22-b вышли на заданные орбиты.
Shiyan-23 будет использоваться для научных экспериментов, в то время как два других аппарата были запущены для орбитальных испытаний технологий по мониторингу космического пространства.
Нынешний запуск стал 459-й по счету миссией ракет-носителей серии "Чанчжэн".
Ссылки:
https://tv.cctv.com/cctvrussian

###

Тасс (tass.ru), 09.01.2023 07:04, Китай успешно запустил пять спутников при помощи ракеты частной разработки "Церера-1"
Теги: Китай
https://tass.ru/kosmos/16757347
ПЕКИН, 9 января. /ТАСС/. Китай в понедельник успешно вывел на орбиту пять спутников при помощи ракеты-носителя "Церера-1", разработанной частной компанией Xinghe Power Space Technology. Об этом сообщила газета "Чжунго хантяньбао (http://www.spacechina.com/n25/index.html)", курируемая Китайской корпорацией аэрокосмической науки и техники.
Как уточняется на странице издания в социальной сети WeChat, запуск был осуществлен в 13:04 по пекинскому времени (08:04 мск) с космодрома Цзюцюань на севере страны. Он стал пятым для ракеты этой серии.
На этот раз при помощи "Цереры-1" были запущены космические аппараты "Кэцзи-1", "Тяньци синцзо-13", "Наньтун чжунсюэ" и два метеорологических спутника "Тяньму-1".
Таким образом, 9 января КНР осуществила два первых в 2023 году для народной республики успешных ракетных запуска. Один из них (три спутника - "Шицзянь-23", "Шиянь-22-эй" и "Шиянь-22-би" - при помощи носителя "Чанчжэн-7-эй") был совершен ранее, в 06:00 по местному времени (01:00 мск), со стартовой площадки Вэньчан, расположенной на северо-восточном побережье острова Хайнань.

Пекин активно развивает национальную космическую программу, разрабатывая метеорологические, телекоммуникационные и навигационные спутники, а также технологии для освоения Луны. Китайские специалисты одновременно реализуют проект по исследованию астероидов и Марса. На орбите завершено строительство космической станции КНР.
В 2022 году Китай осуществил 64 запуска, в очередной раз побив собственный национальный рекорд. По этому показателю КНР за указанный период заняла второе место после США.
Ссылки:
http://www.spacechina.com/n25/index.html

###

Тасс (tass.ru), 31.12.2022 09:05, Двигатель для ракеты "Союз-5" прошел первое длительное огневое испытание
Теги: Россия
https://tass.ru/kosmos/16726813
МОСКВА, 31 декабря. /ТАСС/. Специалисты Воронежского центра ракетного двигателестроения успешно провели первое длительное огневое испытание нового ракетного двигателя РД-0124МС на нафтиле, предназначенного для второй ступени перспективной ракеты-носителя "Союз-5". Об этом в субботу сообщили в Роскосмосе.
"В рамках доводочных испытаний двигатель с полноразмерными соплами впервые отработал на огневом стенде время, на 40% превышающее заложенный техническим заданием штатный полетный ресурс в составе ракеты. Запуск и остановка двигателя прошли в соответствии с программой испытания", - говорится в сообщении.
Жидкостный ракетный двигатель РД-0124МС тягой в пустоте 60 тонн работает на жидком кислороде и нафтиле. Он состоит из двух блоков, расположенных на общей раме, в состав каждого из блоков входят по две камеры. Двигатель обеспечивает качание камер в двух плоскостях, а также работу при выключении одного из блоков, в том числе на пониженном режиме тяги.
"Союз-5" разрабатывается для российско-казахстанского проекта "Байтерек". В 2018 году был подписан протокол о внесении изменений в соглашение правительств Казахстана и России о создании на Байконуре комплекса "Байтерек" от 22 декабря 2004 года. Он определяет обязанности сторон по проекту, вывод из аренды и передачу казахстанской стороне объектов наземной космической инфраструктуры комплекса "Зенит-М" для модернизации.

Казахстан отвечает за создание наземной инфраструктуры путем модернизации комплекса "Зенит-М". Россия разрабатывает ракету "Союз-5", которую планируется запускать оттуда. Первый старт запланирован на четвертый квартал 2023 года.


###

Naked Science (naked-science.ru), 01.02.2021 13:21, Сергей Васильев, Толстая литосфера Венеры вряд ли способна к тектонике плит
Теги: Астрономия, Венера, литосферные плиты, тектоника плит, ударный кратер
Аннотация: Структура крупнейшего ударного кратера Венеры показала, что толщина ее литосферы слишком велика, а на планете нет и не может быть никакой тектоники плит.
https://naked-science.ru/article/astronomy/tolstaya-litosfera-venery-vryad-li-sposobna-k-tektonike-plit
270-километровый ударный кратер Мид (https://ru.wikipedia.org/wiki/Мид_(кратер)) — крупнейший на Венере, окруженный внутренним и внешним кольцами расплавленной и застывшей породы. Кратер появился, по разным оценкам, от 300 миллионов до миллиарда лет назад. Ученые из Брауновского университета смоделировали его образование, чтобы лучше понять строение литосферы Венеры в то далекое время.
Судя по полученным результатам, на соседней планете не было и не могло быть движения тектонических плит. Об этом Эван Бьоннс (Evan Bjonnes) и его коллеги пишут в статье (https://www.nature.com/articles/s41550-020-01289-6), опубликованной в журнале Nature Astronomy. По их словам, полученные данные опровергают существующие гипотезы (https://naked-science.ru/article/sci/litosfera-venery-okazalas) о том, что вплоть до сравнительно недавнего времени Венера оставалась тектонически активна.
На Земле свидетельства тектоники плит встречаются повсюду. Известны зоны субдукции, где одни плиты погружаются под другие, а также срединно-океанические хребты, где происходит образование новой коры. Орбитальные аппараты, работающие на орбите Венеры, обнаруживают сходные детали и на ее поверхности. Однако действительно ли они имеют такое же происхождение, разобраться нелегко: бурная и сверхплотная атмосфера и адские условия на поверхности сильно затрудняют детальные наблюдения.
Поэтому Бьоннс и его коллеги обратились к альтернативному источнику данных о литосфере Венеры. Древний ударный кратер Мид сохранил два концентрических кольца по краю, причем их размеры определяются температурным градиентом коры. Расчеты показали, что в момент удара этот градиент был невелик, то есть с ростом глубины температура повышалась постепенно и не слишком сильно.
Жизнь на Венере и разворот «Роскосмоса»: действительно ли фосфин говорит о населенности ближайшей...
​​Недавнее открытие биомаркера фосфина в атмосфере Венеры породило немало споров — есть ли там жизнь? С этим пока не все ясно. Но определенно ясно то, что «Роскосмос» учится использовать хайп в цел...
naked-science.ru
(https://naked-science.ru/article/astronomy/zhizn-na-venere?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle)
Это, в свою очередь, указывает, что кора Венеры была (а возможно, и остается) слишком толстой для того, чтобы раскалываться на независимо движущиеся плиты. «Представьте замерзающий зимой водоем, — объясняет (https://www.brown.edu/news/2021-01-28/mead) Эван Бьоннс. — Сперва лед появляется на поверхности, а на глубине все еще чуть теплее. Постепенно вода промерзает, и лед становится все толще».
Ссылки:
https://ru.wikipedia.org/wiki/Мид_(кратер)
https://www.nature.com/articles/s41550-020-01289-6
https://naked-science.ru/article/sci/litosfera-venery-okazalas
https://naked-science.ru/article/astronomy/zhizn-na-venere?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle
https://www.brown.edu/news/2021-01-28/mead

###

Naked Science (naked-science.ru), 31.12.2022 15:03, Анна Новиковская, Астрономы обнаружили ключевое сходство между Венерой и Землей
Теги: Астрономия, Венера, литосфера, тектоника плит
Аннотация: Долгое время ученые полагали, что толщина литосферы Венеры слишком велика, чтобы поддерживать движение тектонических плит. Однако теперь калифорнийские исследователи заявили, что это не так, и в тектоническом плане Венера не слишком отличается от Земли.
https://naked-science.ru/article/astronomy/active-venus
Хотя Венера (https://ru.wikipedia.org/wiki/Венера) — ближайшая к Земле планета Солнечной системы, на первый взгляд они выглядят совершенно разными. Если Земля поддерживает условия, подходящие для разнообразных форм жизни, описать Венеру как «негостеприимную» будет огромным преуменьшением.
Чтобы передать на Землю первые снимки поверхности этой планеты, советскому аппарату «Венера-9» (https://ru.wikipedia.org/wiki/Венера-9) в 1975 году пришлось преодолеть крайне плотную атмосферу и облака из серной кислоты, после чего приземлиться на «раскаленную сковородку», нагретую до 464 градусов Цельсия, так что не удивительно, что даже надежная советская техника вышла из строя спустя 53 минуты после посадки.
Толстая литосфера Венеры вряд ли способна к тектоник...
Структура крупнейшего ударного кратера Венеры показала, что толщина ее литосферы слишком велика, ...
naked-science.ru
(https://naked-science.ru/article/astronomy/tolstaya-litosfera-venery-vryad-li-sposobna-k-tektonike-plit?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle)
Однако, несмотря на недружелюбный характер, Венера относится к планетам земной группы (https://ru.wikipedia.org/wiki/Планеты_земной_группы) и намного больше, чем Марс или Меркурий, похожа на нашу родную планету. Ключевое сходство — то, что и Земля, и Венера излучают в космос тепловую энергию, а значит, ее ядро все еще достаточно горячее и может поддерживать активное движение тектонических плит (https://ru.wikipedia.org/wiki/Тектоника_плит).
Ранее ученые предполагали, что литосфера (https://ru.wikipedia.org/wiki/Литосфера) Венеры слишком толстая и вязкая, чтобы тектонические плиты скользили, врезались и расходились на ее поверхности, но теперь астрономы из Лаборатории реактивного движения (https://ru.wikipedia.org/wiki/Лаборатория_реактивного_движения) в Калифорнии (США) установили, что в этом отношении две планеты-соседки практически неотличимы друг от друга.
К таким выводам они пришли, проанализировав данные, собранные межпланетной станцией «Магеллан» (https://ru.wikipedia.org/wiki/Магеллан_(космический_аппарат)) в 1990-х годах и рассчитав толщину литосферы, измерив изгиб внутри поверхностных образований, называемых венцами (https://ru.wikipedia.org/wiki/Список_венцов_на_Венере), образовавшихся в результате геологической и вулканической активности. Используя данные альтиметрии (https://ru.wikipedia.org/wiki/Альтиметрия) «Магеллана», они определили среднюю толщину литосферы в 75 точках 65 венцов: 11±7 километров.  
Один из венерианских венцов, венец Артемиды / © wikipedia.org
Астрономы рассчитали, что, судя по количеству излучаемого тепла, Венера в среднем тектонически активнее Земли, и с точки зрения нашей планеты она сейчас находится на ранней стадии геологического развития, будучи аналогом Земли времен архея (https://ru.wikipedia.org/wiki/Архей) (около 4-2,5 миллиарда лет назад). Единственное серьезное отличие — отсутствие на поверхности Венеры глобального океана, который сформировался (https://agupubs.onlinelibrary.wiley.com/doi/10.1029/2020AV000323) на Земле еще на самых ранних стадиях ее развития.
Исследование опубликовано (https://www.nature.com/articles/s41561-022-01068-0) в журнале Nature Geoscience.
Ссылки:
https://ru.wikipedia.org/wiki/Венера
https://ru.wikipedia.org/wiki/Венера-9
https://naked-science.ru/article/astronomy/tolstaya-litosfera-venery-vryad-li-sposobna-k-tektonike-plit?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle
https://ru.wikipedia.org/wiki/Планеты_земной_группы
https://ru.wikipedia.org/wiki/Тектоника_плит
https://ru.wikipedia.org/wiki/Литосфера
https://ru.wikipedia.org/wiki/Лаборатория_реактивного_движения
https://ru.wikipedia.org/wiki/Магеллан_(космический_аппарат)
https://ru.wikipedia.org/wiki/Список_венцов_на_Венере
https://ru.wikipedia.org/wiki/Альтиметрия
https://ru.wikipedia.org/wiki/Архей
https://agupubs.onlinelibrary.wiley.com/doi/10.1029/2020AV000323
https://www.nature.com/articles/s41561-022-01068-0

###

Naked Science (naked-science.ru), 17.09.2020 10:28, Александр Березин, Жизнь на Венере и разворот «Роскосмоса»: действительно ли фосфин говорит о населенности ближайшей планеты и почему Россия решила резко активизировать свои венерианские планы?
Теги: Астрономия, Венера, внеземная жизнь, космонавтика, космос, Роскосмос, Выбор редакции
Аннотация: ​​Недавнее открытие биомаркера фосфина в атмосфере Венеры породило немало споров — есть ли там жизнь? С этим пока не все ясно. Но определенно ясно то, что «Роскосмос» учится использовать хайп в целях пиара: госкорпорация уже предложила взять пробу вещества этой планеты. Для этого она откажется от совместного с NASA проекта «Венера-Д» («Д» — значит «Долгоживущая») и заменит его «своим». Но есть ли повод для такой спешки? О чем на самом деле говорит фосфин в облаках второй планеты? И, главное, справится ли Россия с забором образцов оттуда? Попробуем разобраться.
https://naked-science.ru/article/astronomy/zhizn-na-venere
Что обнаружили

Согласно научной работе, вышедшей (https://www.nature.com/articles/s41550-020-1174-4) в Nature Astronomy, на высотах в 50-60 км на Венере обнаружен фосфин – газ с формулой РН3. Концентрация его была невелика, лишь 20 частей на миллиард, незначительно выше, чем метана на Марсе, но оспорить сам факт  регистрации очень трудно. 
СМИ – в этот раз весьма корректно – отписали, что это очень вероятный признак жизни. Стоит разобраться, почему. Во-первых, фосфин весьма химически активен. В итоге он разлагается при повышенной температуре на чистый фосфор и водород, из атомов которых и состоит. Во-вторых, фосфор после этого в условиях венерианских облаков должен элементарно падать вниз, где никакого водорода, заметим, нет – то есть из мест, где его заметили земные телескопы, фосфин должен постоянно исчезать. В-третьих, что особенно важно, на Земле этот газ до появления людей образовывался только одним способом – в результате деятельности анаэробных бактерий. 
Снимки поверхности Венеры, полученные советскими посадочными аппаратами / ©Роскосмос
К сожалению, газ этот даже на Земле настолько редкий (https://www.sciencedirect.com/science/article/abs/pii/S0960852401000323?via=ihub), что выяснить, какие именно бактерии его производят, сложно. Однако то, что у нас он в основном биогенный – факт, поскольку появляется буквально на каждой свалке или у любой большой кучи навоза. И там, и там бурно размножаются анаэробные микробы (бактерии и, в меньшей степени, археи (https://ru.wikipedia.org/wiki/Археи)), но никакие неорганические процессы, способные породить такое соединение, там не идут.
Возможна ли наработка фосфина небиогенным путем в принципе? Да, безусловно: например, его следы есть в атмосфере Юпитера. Но расчеты показывают, что для его получения без участия живых существ, с их сложными каталитическими процессами, нужно огромное количество энергии. 
В случае Юпитера понятно, откуда она может взяться: фосфин там поднимается из недр планеты, где температуры измеряются тысячами градусов, что позволяет фосфору вступать в реакцию с водородом, весьма распространенном на газовых гигантах. В итоге неизбежно образуется именно фосфин. Но на Венере намного прохладнее, чем в юпитерианских недрах, а главное — в ее атмосфере почти нет свободного водорода. 
Панорамные фото Венеры, сделанные одним из советских спускаемых аппаратов / ©Роскосмос
Чисто теоретически, фосфин на Венере может выбрасываться вулканами (хотя на Земле в заметных масштабах это не происходит). Однако авторы работы в Nature Astronomy корректно замечают, что нужный для этого масштаб извержений должен быть в сотни раз выше земного. И это если исходить из самых оптимистичных оценок живучести фосфина в атмосфере второй планеты. Но на Венере нет следов текущей вулканической активности в сотни раз выше земной. Кроме того, в нижних слоях ее атмосферы фосфин, из-за высокой температуры, должен распадаться в течении часа, то есть почти сразу после извержений.
Из-за всего этого еще в 2019 году исследователи из Массачусетского технологического института (США) в своей работе в журнале Astrobiology предложили (https://www.liebertpub.com/doi/abs/10.1089/ast.2018.1954?journalCode=ast) искать фосфин на экзопланетах земного типа как признак наличия там жизни. Именно по ее следам организовали анализ спектров венерианской атмосферы – и обнаружили там этот газ.

Но как же быть с «адскими условиями на Венере», где «не может быть ничего живого»?

Читатель вправе усомниться. В школе рассказывают, что на Венере +462 °C по Цельсию, то есть теплее точки плавления свинца. А давление в 93 раза выше, чем на поверхности Земли – если туда поместить сосновый кубик, его сожмет в два раза, на Земле такое же давление в 930 метрах под водой.  Какая жизнь может существовать в таких условиях?
Однако никакого парадокса тут нет. Дело в том, что на высоте 50-60 километров Венера, как установили еще советские зонды полвека тому назад, имеет примерно земные температурные условия: например, на 55 километрах там неизменно 21 градус по Цельсию. Днем и ночью, зимой и летом – благо из-за плотности венерианской атмосферы сезонных и суточных колебаний температуры там просто нет. Давление на 55 километрах равно половине земного на уровне моря – или такое же, как у нас на 5,5 километрах. Это вполне приемлемо для земных микробов, и даже некоторые альпинисты, после длительной адаптации, вполне действуют при таком давлении.
Именно из-за примерно земных температур и давления облака Венеры уже очень давно предложили (https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&) как возможную зону колонизации. Дело в том, что, с точки зрения здоровья колонистов, главным ресурсом других планет считают наличие на них приличной гравитации. Иначе нужны или центрифуги для повышенного тяготения во время сна, или смирение перед процессами деградации костной и мышечной ткани живущих там людей. Венерианский уровень гравитации – 90,4% от земного, и в этом плане лучшего объекта для колонизации в этой системе нам не найти.
Колония на Марсе к 2050 году: построит ли Илон Маск город на Красной планете
SpaceX рассчитывает к 2050 году создать на Марсе колонию на миллион человек. Звучит абсурдно: осталось всего 30 лет, а до первого полета на Марс еще многие годы. Некоторые ученые, включая российски...
naked-science.ru
(https://naked-science.ru/article/cosmonautics/koloniya-na-marse-postroit-li-ilon-mask-gorod-na-krasnoj-planete?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle)
При этом, в отличие от Марса, на высоте 55 километров колонистам не потребуются ни подогрев, ни охлаждение: достаточно будет поддерживать аэростаты с их «воздухоплавательными« городами на одной и той же высоте. Уровень солнечного освещения на 55 километрах даже чуть выше земного, то есть в прозрачных галереях на «спине» гигантских дирижаблей вполне можно будет выращивать земные растения. На высоте 100 километров там есть (https://www.sciencedirect.com/science/article/abs/pii/S0019103511003277) озоновый слой, хотя и много тоньше земного. 
Конечно, на 55 километрах уровень ультрафиолета выше «нашей» нормы, но обычное стекло легко блокирует его до значений ниже земных. Хотя серьезного магнитного поля у второй планеты нет, уровень космической радиации там довольно низок: ведь атмосфера, как и на Земле, эффективно поглощает космические лучи. В общем, как отмечает (https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus) Джеффри Лэндис из NASA: «Атмосфера Венеры – самая землеподобная среда в Солнечной системе (после Земли)».
Кстати, когда мы говорим «аэростат», это вовсе не значит, что для такой колонизации потребовались бы специальные легкие газы, которыми наполняют аэростаты на Земле. На самом деле, для этого даже не нужен аэростат в привычном нам смысле слова. 
Дело в том, что обычный земной воздух намного легче венерианского – почти чистого углекислого газа. Поэтому простая гермооболочка, наполненная банальным воздухом, будет плавать в атмосфере Венеры. А при наличии компактного атомного реактора и/или растений в прозрачных галереях колонисты всегда смогут получить кислород из окружающего колонию-аэростат углекислого газа газовой оболочки второй планеты.
Работники NASA констатируют (https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus), что километровая шарообразная гермооболочка на Венере будет иметь подъемную силу в 0,7 миллионов тонн – вполне достаточную, чтобы поддержать немалых размеров поселение. Двухкилометровый шар будет поднимать уже примерно шесть миллионов тонн. 
Остается последнее возражение: венерианские облака содержат капельки серной кислоты. Не разъест ли она конструкции такой колонии? На этот вопрос давным-давно ответили (https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus) советские инженеры. Еще в 1985 году созданные ими аэростаты вполне успешно исследовали облачный слой Венеры, и при этом их оболочка была сделана из тонкого слоя обычнейшего тефлона. 
Макет советского аэростата, который в 1985 году стал первым в истории чисто атмосферным летательным аппаратом, примененным для изучения других планет / ©Wikimedia Commons 
Тогда, впервые в истории землян, два аэростата пару суток подряд смогли исследовать другое небесное тело, проделав над ним путь в одиннадцать тысяч километров, прежде чем опустились (следуя плану) на поверхность планеты. В процессе они заметно уточнили наши представления об облачном слое планеты, а также открыли наличие на Венере сильных гроз.
Кстати, на сегодня – спустя 45 лет – человечество так и не смогло повторить советское достижение. Ни разу с 1980-х годов летательным аппаратом аэростатного, самолетного или вертолетного типа так и не удалось исследовать другую планету. Лишь в ближайшие годы миниатюрный дрон американского марсохода сможет начать экспериментальное трехминутные полеты на Марсе.
По сути дела, советские миссии показали, что любой человек в тефлоновом костюме с кислородным аппаратом может (https://www.scientificamerican.com/article/venus-ussr-1967-mission/) прогуливаться на поверхности колонии-аэростата безо всякого космического скафандра – а вот на Марсе и Луне, как мы уже писали, нужда в таких скафандрах – очень большая и трудно решаемая проблема.

Откуда там взяться жизни?

Итак, в принципе, фосфин на второй планете действительно может быть продуктом жизнедеятельности анаэробных бактерий – по крайней мере, науке на сегодня неизвестны небиогенные процессы, которые могли бы образовать его там. Но возникает другой вопрос: а откуда на Венере такие микроорганизмы?
Конечно, соблазнительно было бы предположить, что их принесли сами земляне. Целый ряд советских спускаемых аппаратов – да и те же аэростаты – проходили дезинфекцию, которая, как известно сегодня, недостаточна для того, чтобы убить наиболее живучие земные бактерии и археи. Но это достаточно сомнительно: многие анаэробные микробы плохо переносят насыщенный кислородом воздух, поэтому их наличие в сборочных цехах «НПО им. Лавочкина» в советскую эпоху представляется маловероятным.
Есть куда более простое объяснение. В 2016 году выяснилось (https://life.ru/p/887208), что (https://arxiv.org/abs/1608.00706) в ранней стадии истории Солнечной системы Венера могла быть существенно более пригодной для возникновения жизни, чем Земля. Ведь сутки на второй планете нашей системы в 243 раза длиннее нынешних земных – а это крайне мощный охлаждающий фактор планетарного климата. 
Согласно расчетам американских и шведских исследователей, 2-3 миллиарда лет назад Венера могла выглядеть примерно так, то есть иметь глобальный океан, покрывающий основную часть ее поверхности / ©Wikimedia Commons
Длинная ночь означает, что куда большая, чем на Земле, часть тепла, полученного от солнечных лучей, будет переизлучена в космос в виде инфракрасного излучения. То есть хотя Венера и получает почти в полтора раза больше солнечной энергии, чем наша планета, но при земном составе атмосферы она имела бы среднюю температуру, равную нашей.
Более того, 0,7-2,9 миллиарда лет тому назад эта температура должна была быть даже чуть ниже, чем на сегодняшней Земле – примерно как у нас 15 тысяч лет назад, то есть около плюс 11 по Цельсию. По расчетам американских и шведских исследователей, в ту пору океанами и морями было покрыто до 60% поверхности второй планеты, а атмосфера была в основном азотной – как и на ранней Земле. По мнению (https://arxiv.org/abs/1608.00706) некоторых исследователей, нельзя исключать, что именно на Венере впервые в Солнечной системе и возникла жизнь.

Но как она могла там уцелеть?

Как известно, в последние сотни миллионов лет на Венере начались гигантские извержения, выбросившие в атмосферу огромное количество углекислого газа. Он поднял температуру выше плюс 450 по Цельсию, в результате океаны и моря планетой давно потеряны, и ее поверхность больше не пригодна для жизни земного типа. Получается, даже если эта планета и была прародиной жизни в нашей системе, сейчас она должна стать мертвой. Даже относительно благоприятные условия в облачном слое не помогут: ведь жизнь не может витать в облаках сотни миллионов лет подряд. Или все-таки может?
Ответ на этот вопрос в другой публикации попробовала (https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&) получить группа во главе с Сарой Cиджер (Sara Seager), одним из авторов и недавней работы по венерианскому фосфину. Вместе с соавторами она обратилась к итогам исследования тропо- и стратосферы Земли и выяснила, что микробы там есть до высоты в десятки километров, причем вплоть до верхней части тропосферы – где температура и давление куда ниже, чем в венерианских облаках – они сохраняют метаболическую активность. Следов деления у них там не нашли, но надо понимать, что исследовать одноклеточные в таких условиях крайне сложно, поэтому такое деление (размножение) исключать никак нельзя.
Но проблема в том, что облака Венеры состоят в основном из серной кислоты (не менее, чем на 85%). Водяной пар там тоже есть, но в концентрации 40-200 частей на миллион, что исключительно мало. Скажем, на Земле самый сухой воздух в Атакаме – но и там относительная влажность 2%, а в облаках Венеры – 0,07%. В таких условиях вода, в принципе, все равно может концентрироваться в количествах, формально достаточных для выживания – в каплях серной кислоты, составляя примесь, которая не превышает 15%. Кроме того, в этих каплях молекулы воды как бы «привязаны» к молекулам серной кислоты, и поэтому их использование для любой потенциальной местной жизни затруднено.
И тем не менее, отрицать вероятность существования жизни даже в таких условиях нельзя. Во-первых, в облаках Венеры давным-давно нашли сероводород и сернистый газ, которые реагируют друг с другом. И поэтому, строго говоря, не могут существовать без внешней подпитки за счет каких-то необычных химических реакций. Там же найден (https://www.sciencedirect.com/science/article/abs/pii/S0032063399000367?via=ihub) и карбонила сульфид (O=C=S). 
На Земле это соединение – четкий биомаркер, по изменению следов которого в атмосфере исследователи полярных ледовых кернов могут точно определить, как меняется биомасса на нашей планете с течением времени. Кроме того, получить карбонила сульфид не биогенно очень сложно, и до появления промышленности он на планете производился исключительно живыми организмами – в силу наличия у них крайне эффективных катализаторов.
Наконец, отмечает Сиджер с соавторами, на снимках в УФ-диапазоне видно, что в облаках Венеры есть какие-то непонятные образования, поглощающие ультрафиолет – основную его часть, достигающую этого слоя атмосферы. Размеры этих частиц варьируют в микрометровом диапазоне (на нашей планете такие размеры часто имеют бактериальные споры) до еще больших. Это, вкупе с наличием на Земле фотосинтезирующих анаэробных микроорганизмов, использующих (https://ru.wikipedia.org/wiki/Зелёные_серобактерии) вместо углерода серу, в принципе позволяет ожидать, что какие-то возможности для фотосинтеза есть и в венерианских облаках. 
Зеленые серобактерии в земной лаборатории. В отличие от привычных нам фотосинтезирующих организмов, они не дышат кислородом, и нуждаются только в сероводороде, водороде и сере / ©Wikimedia Commons
Ей не сможет помешать относительно высокий ультрафиолет – напротив, на Земле есть живые организмы (грибы Cryptococcus neoformans), использующие ионизирующее коротковолновое излучение как источник энергии. Более того, отмечает Сиджер, на нашей планете такие любители радиации встречаются как в природе (антарктические горы), так и в техногенной среде (компоненты систем охлаждения атомных реакторов, МКС). То есть для многих живых организмов ультрафиолет – не проблема, а источник полезной энергии.
Из всего этого ее группа делает вывод: на Венере возможно существование жизни в облаках, но жизнь это необычная, более напоминающая земной «серный» фотосинтез без доступа к кислороду, нежели что-то еще. Жизненный цикл таких микробов-фотосинтетиков прост: в облачном слое они, за счет гидрофильной оболочки, становятся центром образования капелек из серной кислоты и воды. Затем начинают фотосинтезировать, используя находящийся вокруг них сернистый газ (SO2) и воду. Из их молекул они производят H2SO4 ту самую серную кислоту, из которой, собственно, и состоят в основном местные облака. 
Фосфор, как и, например, железо, – неизбежный участник жизненного цикла самых разных организмов, поэтому в ходе ряда реакций он может, в следовых количествах, выделяться в виде фосфина, который и нашли исследователи с помощью телескопов. 
Кстати, мы не зря упомянули железо: советские аппараты, включая аэростаты, нашли внизу облачного слоя следы хлора. Между тем, как отмечает Сиджер, от поверхности планеты с восходящими потоками поднимает хлорид железа. Если местные микробы используют это железо, они неизбежно должны выбрасывать в окружающую среду какие-то количества свободного хлора.
Жизненный цикл гипотетических венерианских микробов в представлении группы Сиджер. Те, что опускаются ниже облачного слоя, погибают от холода, но их споры с конвекцией в ряде случаев снова вернутся на высоту / ©Wikimedia Commons
Сиджер и соавторы приводят и пример существа, близкого к возможной венерианской жизни – фотосинтезирующего прокариота Prochlorococcus. Это очень небольшой организм, диаметром 0,5-0,7 микрометров, у которого, из-за бедной фосфором среды обитания, внешняя стенка состоит из соединений серы и сахаров. 99% липидов в составе клеточной мембраны у этого организма вместо фосфатных групп включают сульфатные – и сходная адаптация имела бы смысл на Венере, с ее дефицитом фосфора и избытком серы.
Астробиологи описали выживание микробов в атмосфере Венеры
Поверхность Венеры слишком горяча для любой мыслимой жизни, но вот высоко в атмосфере условия не так экстремальны, а восходящие потоки вполне способны удерживать местных микробов от падения вниз.
naked-science.ru
(https://naked-science.ru/article/astronomy/astrobiologi-opisali-vyzhivanie-mikrobov-v-atmosfere-venery?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle)
Капли, в которых находятся такие фотосинтезирующие организмы, нарабатывающие серную кислоту, со временем растут в размерах (за счет окружающих паров серной кислоты и воды) и начинают опускаться вниз. При этом местные организмы должны переходить в фазу производства спор, а затем – погибать. Восходящие потоки неизбежно поднимут часть капель на высоту, где часть спор сможет дать начало новому жизненному циклу в венерианских облаках.
Разумеется, подобная среда будет весьма непростой для выживания. На Земле нет мест, где бактерии или археи могли бы жить в серной кислоте, слегка разбавленной водой. Поэтому мы достоверно не знаем, способны ли они защитить себя от воздействия кислот в таких условиях.  Но и исключать этот сценарий заранее невозможно.

Адекватна ли реакция Роскосмоса? Стоит ли венерианский мираж разрыва отношений с NASA?

Итак, мы установили, что жизнь на Венере, в принципе, возможна. А вот с некоторыми аспектами деятельности разумной жизни на Земле вопросы все еще остаются. 
15 сентября 2020 года на сайте Роскосмоса появилось сообщение (https://www.roscosmos.ru/29217/), реагирующее на открытие фосфина и утверждающее:
«…принято решение о реализации ранее запланированной миссии «Венера-Д», включающей посадочные и орбитальные модули, в качестве независимого национального проекта без широкого привлечения международной кооперации. В рамках комплексных исследований планеты среди прочего будут изучены пробы ее грунта и атмосферы, а также исследована природа эволюционных процессов Венеры, перенесшей ранее, как утверждается, климатическую катастрофу, связанную с парниковым эффектом, о котором сегодня так много говорят применительно к Земле».
Что это? Прекрасно известно, что бюджет Роскосмоса в полдюжины раз меньше, чем у NASA. Так какой смысл отказываться от сотрудничества с Агентством, ранее предусмотренным в составе программы «Венера-Д»? Однако при внимательном взгляде на вопрос причины отказа от кооперации понять становится значительно проще.
Изображения Венеры, полученные в 1975 году советским посадочным аппаратом «Венера-9». Оригинальное изображение вверху, ниже два поправленных в нашу эпоху с помощью алгоритмов заполнения сходным содержимым  / ©Роскосмос
Как отмечает N+1, чей редактор пообщался (https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9) с членами Совета РАН по космосу, еще в июле 2020 года Роскосмос предложил коренным образом пересмотреть миссию «Венера-Д». По пересмотренному варианту, уже в конце 2020-х годов к планете могла полететь посадочная станция с рядом аэростатов, причем станция эта должна была взять с поверхности планеты образец грунта – и затем доставить его на Землю.
Легко видеть, что в международной кооперации такой проект реализовать все равно было нельзя: NASA никогда бы не пошло на это. Начать с того, что забор грунта требует его доставки на Землю, что с поверхности Венеры сделать трудно. Поэтому предложение Роскосмоса предусматривало подъем образца грунта на аэростате в верхние слои атмосферы. Оттуда ракета, поднимаемая аэростатом, должна была вывести образец в космос, где он бы направился к Земле.
Это задачи исключительно высокой сложности и, откровенно говоря, требующие огромной массы посадочного модуля. Речь идет о многих тоннах: как мы уже упоминали, гравитация на Венере – 90% от земной, и возврат грунта оттуда, по этой причине, даже с аэростатом будет крайне энергозатратным. Естественно,  NASA не пошло бы на столь рискованный проект – это не стиль Агентства. 
Возникает вопрос: зачем это Роскосмосу? У России с тех самых советских миссий к Венере не было удачных межпланетных миссий даже с умеренно сложными задачами. Последняя попытка такой миссии утонула в Тихом океане («Фобос-грунт»). Попытка прыгнуть от нуля миссий сразу к миссии такого огромного масштаба и сложности выглядит крайне специфично – попросту говоря, как авантюра с неотработанными средствами исполнения. Неудивительно, что  члены Совета РАН по космосу высказались против (https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9) нее.
Четко понять мотивы руководства Роскосмоса в данном случае сложно. Наиболее вероятных версий две: либо оно не рассчитывает досидеть в своих креслах до конца 2020-х годов и отвечать за риски такого проекта; либо настолько хочет впечатляющих и успешных картинок для публики, что готово даже на такие, говоря языком РАН, «полуфантастические» (https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9) прожекты, лишь бы создать у масс благоприятное впечатление о своей деятельности.
Если верен один из перечисленных случаев – то понять руководство Роскосмоса можно. Всем наблюдателям космической отрасли достаточно очевидно, что в 2020-х годах SpaceX отладит свой сверхтяжелый и самый большой в истории человечества космический носитель Starship. После этого США неизбежно попадут на Луну, а через несколько лет – и на Марс. Годы упорного игнорирования Роскосмосом проектов Маска (в виде нежелания создавать конкурирующие носители для полета на Марс)  исключают для нашей страны отправку туда экспедиций в обозримом будущем. 
На таком фоне нужно срочно объявить какой-то громкий проект, причем степень его реализуемости в обозримые сроки может быть не особенно важна. Ведь ясно, что после начала полетов Starship всю российскую космическую программу придется все равно пересмотреть, «Ангара» мгновенно окажется глубоко устаревшим, и нашей стране переделывать придется все заметные космические проекты вообще. На фоне всего этого за невыполненный проект доставки грунта с Венеры вряд ли кто спросит.
Ссылки:
https://www.nature.com/articles/s41550-020-1174-4
https://www.sciencedirect.com/science/article/abs/pii/S0960852401000323?via=ihub
https://ru.wikipedia.org/wiki/Археи
https://www.liebertpub.com/doi/abs/10.1089/ast.2018.1954?journalCode=ast
https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&
https://naked-science.ru/article/cosmonautics/koloniya-na-marse-postroit-li-ilon-mask-gorod-na-krasnoj-planete?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle
https://www.sciencedirect.com/science/article/abs/pii/S0019103511003277
https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus
https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus
https://www.bbc.com/future/article/20161019-the-amazing-cloud-cities-we-could-build-on-venus
https://www.scientificamerican.com/article/venus-ussr-1967-mission/
https://life.ru/p/887208
https://arxiv.org/abs/1608.00706
https://arxiv.org/abs/1608.00706
https://www.liebertpub.com/doi/10.1089/ast.2020.2244?fbclid=IwAR2GjR1qi64aSv5pbJ8JmutGRWowo2_Ailf3CoxxOFmL6ZYuIq3OeRS2TZI&
https://www.sciencedirect.com/science/article/abs/pii/S0032063399000367?via=ihub
https://ru.wikipedia.org/wiki/Зелёные_серобактерии
https://naked-science.ru/article/astronomy/astrobiologi-opisali-vyzhivanie-mikrobov-v-atmosfere-venery?utm_source=inarticle&utm_medium=inarticle&utm_campaign=inarticle
https://www.roscosmos.ru/29217/
https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9
https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9
https://nplus1.ru/blog/2020/09/16/semifantastic?code=1cf258376cbcc12621faa39c73e4ced9

###

Naked Science (naked-science.ru), 26.03.2018 06:03, Редакция Naked Science, Литосфера Венеры оказалась «промежуточным вариантом» между Марсом и Землей
Теги: Наука, Венера, кора, литосферные плиты, тектоника плит
Аннотация: Кора Венеры разбита на фрагменты, которые перемещаются в крайней тесноте, показывая нечто среднее между поведением литосфер Земли и Марса.
https://naked-science.ru/article/sci/litosfera-venery-okazalas
Новые карты поверхности Венеры, полученные на основе снимков, которые были сделаны еще в 1990-х годах американским зондом Magellan, показывают сложную сеть хребтов и разломов — весьма похожую на то, что создает на Земле тектоника плит. Более того, на краях венерианских равнин можно рассмотреть свидетельства трения блоков коры друг о друга. Об этом рассказал планетолог из Университета штата Северная Каролина Пол Бирн (Paul Byrne), выступивший с докладом (https://www.hou.usra.edu/meetings/lpsc2018/pdf/1935.pdf) на конференции Lunar and Planetary Science.
 
Современные Земля и Марс представляют собой два противоположных полюса в строении коры небольших каменистых планет. Марс покрыт цельной, неподвижной литосферой; Земля же разделена на крупные фрагменты, плавающие по поверхности магмы, то сходящиеся, то расходящиеся друг с другом. Однако чем больше мы узнаем Венеру, тем скорее она кажется «промежуточным вариантом» между этими двумя: «Это не совсем тектоника плит, но и не совсем не тектоника плит», — говорит (https://www.sciencenews.org/article/venus-may-be-home-new-kind-tectonics) Пол Бирн.
 

 
Действительно, кора Венеры разделена на отдельные плиты. С другой стороны, земные плиты движутся более или менее независимо друг от друга. Венерианские образуют тесные связки, как льдины на весеннем озере — именно с ними сравнивает это движение Ричард Гейл (Richard Ghail) из Имперского колледжа Лондона, выступивший (https://www.hou.usra.edu/meetings/lpsc2018/pdf/1408.pdf) следом. Ученый рассказал об обнаружении на поверхности Венеры двух четко очерченных низин (Nuwa Campus и Lada Campus), напоминающих обликом земные — Таримскую и Сычуаньскую впадины на территории Китая.
 
При таком тесном соседстве литосферных плит их перемещение может обеспечиваться высокой температурой поверхности Венеры, которая превышает 450 °С. «Породы должны быть размягчены», — объясняет Пол Бирн, что, по-видимому, облегчает движение плит, запускаемое конвекцией в вязкой мантии планеты.
Ссылки:
https://www.hou.usra.edu/meetings/lpsc2018/pdf/1935.pdf
https://www.sciencenews.org/article/venus-may-be-home-new-kind-tectonics
https://www.hou.usra.edu/meetings/lpsc2018/pdf/1408.pdf

###

Хабр (habr.com), 17.12.2022 14:29, Vin_Z, «Чтение — всему голова!» Переводим электронные книги формата .EPUB с помощью Python
Теги: python, epub, beautiful soup, софт
https://habr.com/ru/post/706118/
Разберёмся что “под капотом” формата EPUB и как перевести текст, но не переводить код в книге. Познакомимся с библиотекой Ebook Lib (http://docs.sourcefabric.org/projects/ebooklib/en/latest/index.html#), а также узнаем для чего нам понадобиться библиотека Beautiful Soup (https://beautiful-soup-4.readthedocs.io/en/latest/index.html?highlight=attrs#ulSoup/).
Занимаясь программированием, в русскоязычном сегменте интернета, столкнулся с тем, что много литературы на интересующие меня темы на английском языке. Либо есть перевод, но специфика отрасли такая, что все очень быстро меняется и если заграничные авторы книг исправно выпускают обновление, то перевод зачастую отстает на 2-3 года, что достаточно критично. Прекрасно понимаю, что такие книги и документацию необходимо уметь читать на английском языке, над чем я собственно усердно работаю. С другой стороны читая монументальную литературу на языке оригинала, все еще хочется открыть перевод в соседнем окне и свериться правильно ли ты уловил мысль автора.
Кажется, в чем проблема? Закинул PDF в любом переводчике, а то и в самом браузере перевод автоматический подтягивается, только такие переводчики в основном не распознают код в тексте. Тут возникает основная проблема, которая и сподвигла меня на поиск решения и автоматизации всего процесса. А для этого есть язык программирования Python.

Чем переводить

Для перевода текста я использовал библиотеку Googletrans (https://py-googletrans.readthedocs.io/en/latest/) и написал небольшую функцию, чтобы удобнее было пользоваться.

def translation_func(text):   
    translator = Translator()   
    result = translator.translate(text, dest='ru')   
    return result.text

Так мы подходим к предмету нашего изучения, коим является один из самых популярных форматов электронных книг - EPUB. Все дело в том, что PDF не содержит никакой информации о параметрах текста. А вот EPUB включает в себя набор XHTML- или HTML-страниц, что существенно облегчает перевод текста по нужным нам параметрам.
Чтобы посмотреть структуру электронной книги я воспользовался программой Sigil - EPUB Editor (https://sigil-ebook.com/).

Тут можно определить на какие части делится документ, его форматы (XHTML, HTML или PDF), а главное посмотреть разметку в каких тегах у нас содержится код и по каким признакам его можно будет исключить из перевода.
Вот пример таких тегов:

tag_exeption = ['code', 'a', 'strong', 'pre', 'span', 'html', 'div', 'body', 'head']

Теперь, воспользуемся библиотекой Ebook Lib (http://docs.sourcefabric.org/projects/ebooklib/en/latest/index.html#), примеры ее использования можно посмотреть здесь (https://github.com/aerkalov/ebooklib/tree/master/samples#ebooklib-samples).
С помощью функции ebooklib.epub.read_epub() (http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.read_epub) читаем файл и получаем экземпляр класса  ebooklib.epub.EpubBook (http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.EpubBook).

from ebooklib import epub 
book = epub.read_epub('book.epub')

Все ресурсы в электронной книге (таблицы стилей, изображения, видео, звуки, скрипты и HTML-файлы) являются элементами. Их можно извлечь по типу с помощью функции ebooklib.epub.EpubBook.get_items_of_type() (http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.EpubBook.get_items_of_type).
Вот список элементов которые можно использовать:

* ITEM_UNKNOWN = 0
* ITEM_IMAGE = 1
* ITEM_STYLE = 2
* ITEM_SCRIPT = 3
* ITEM_NAVIGATION = 4
* ITEM_VECTOR = 5
* ITEM_FONT = 6
* ITEM_VIDEO = 7
* ITEM_AUDIO = 8
* ITEM_DOCUMENT = 9
* ITEM_COVER = 10

Мы воспользуемся методом book.get_items() который позволяет получать нам итератор по всем элементам книги - объекты ebooklib.epub.EpubItem (http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.EpubItem). Для перевода нам нужны элементы навигации ITEM_NAVIGATION = 4 и главы книги которые содержатся в элементах  ITEM_DOCUMENT = 9, чтобы их получить по типу используйте метод item.get_type().

for item in book.get_items():
    if item.get_type() == 4:
    …
    if item.get_type() == 9:
    …

Также мы можем получить имя элемента item.get_name(), уникальный идентификатор для этого элемента item.get_id() и его содержимое item.get_content().

for item in book.get_items():
    if item.get_type() == ebooklib.ITEM_DOCUMENT:
        print('==================================')
        print('NAME : ', item.get_name())  
        print('----------------------------------')  
        print('ID : ', item.get_id())    
        print('----------------------------------')   
        print(item.get_content())    
        print('==================================')

...
==================================
NAME :  Text/Chapter_6.xhtml
----------------------------------
ID :  Chapter_6
----------------------------------
b'<?xml version="1.0" encoding="utf-8"?>\r\n<ncx version="2005-1" xmlns="http://www.daisy.org/z3986/2005/ncx/">\r\n<head>\r\n
==================================
...

Получив содержимое главы в формате XHTML, осталось отделить мух от котлет для этого нам поможет библиотека Beautiful Soup (https://beautiful-soup-4.readthedocs.io/en/latest/index.html?highlight=attrs#ulSoup/). Получаем объект soup:

soup = BeautifulSoup(item.get_content(), features="xml")

Теперь нам нужно пробежаться по всем элементам внутри этого объекта, для этого будем использовать атрибут .descendants. Он хорош тем, что в отличие от атрибутов .contents и .children которые учитывают только прямых потомков, позволяет рекурсивно перебирать все дочерние элементы прямых дочерних элементов. Что из себя представляют такие элементы можно посмотреть используя атрибуты: .name - имя тега, .attrs - атрибуты тега (class, id) в формате словаря.

for child in soup.descendants:
   if child.name and child.string:
       print(child.name, '->', child.attrs)

***
h1 -> {'class': 'chapterNumber'}
h1 -> {'class': 'chapterTitle', 'id': '_idParaDest-65'}
p -> {'class': 'normal'}
li -> {'class': 'bulletList'}
a -> {'href': 'https://github.com/example/tree/main/Chapter02'}
***

Атрибут .descendants перебирает все отдельные элементы, которые содержит soup, в том числе и строки между тегов и пустые теги. Через условие отбираем нам нужные элементы, исключая tag_exeption, голый текст (child.name) и теги которые напрямую не содержащие текст (child.string). Полученный атрибутом .string текст переводим функцией translation_func() и потом присваиваем переведенный текст нашему дочернему элементу тем же атрибутом .string .

for child in soup.descendants:
    if child.name not in tag_exeption and child.name and child.string:
    	child.string = translation_func(child.string)

Теги, которые не содержат на прямую текст отдельно прогоняем через атрибут .contents, исключая имена тегов (not content.name), пробелы и переносы ['\n', ' '].

elif not child.name in tag_exeption and child.name: #and count < 10:
    for content in child.contents:
        new_contents = []
        if content.string and content.string not in ['\n', ' '] and not content.name:
            translation_text = translation_func(content.string)
            content = NavigableString(translation_text)
            new_contents.append(content)
            new_contents.append(" ")
    child.clear()
    child.extend(new_contents)

Beautiful Soup использует для хранения фрагментов текста класс NavigableString, переведенный текст делаем объектами этого класса, очищаем содержимое нашего потомка child.clear(), добавляем эти объекты в содержимое потомка используя child.extend(new_contents).
Осталось элементу book присвоить новый контент в виде нашего объекта soup, используя метод .set_content(), не забывая перекодировать.

item.set_content(soup.encode())

Дополнительно, мне понравилось использовать просмотр контента элементов book в браузере с помощью метода .open_in_browser(contents) библиотеки lxml, для этого нужно предварительно перекодировать наш контент воспользовавшись утилитой из библиотеки Ebook Lib (http://docs.sourcefabric.org/projects/ebooklib/en/latest/index.html#) - utils.parse_string(item.get_content()).

from ebooklib import epub, utils
…
contents = utils.parse_string(item.get_content())
html.open_in_browser(contents)

И последнее, что нам нужно - это сохранить переведенную книгу.

epub.write_epub('new_book.epub', book, {})

Весь код  выглядит вот так:from googletrans import Translator
from ebooklib import epub, utils
from bs4 import BeautifulSoup, NavigableString
import lxml.html as html

def open_epub():
    tag_exeption = ["code", 'a', 'strong', 'pre', 'span', 'html',
                    'div', 'body', "head"]
    book = epub.read_epub('Django 4 By Example 2022.epub')
    for item in book.get_items():
        if item.get_id() == "Chapter_7":
            print('NAME : ', item.get_name())
            print('----------------------------------')
            print('ID : ', item.get_id())
            print('----------------------------------')
            print('ITEM : ', item.get_type())

            soup = BeautifulSoup(item.get_content(), features="xml")

            for child in soup.descendants:
                if child.name not in tag_exeption and child.name and child.string:
                    tag_text_before = child.string
                    translation_text = translation_func(tag_text_before)
                    child.string = translation_text
                elif not child.name in tag_exeption and child.name:
                    new_contents = []
                    class_attr = child.attrs.get('class')
                    for content in child.contents:
                        if content.string and content.string not in ['\n', ' '] and not content.name:
                            content = NavigableString(translation_func(content.string))
                            new_contents.append(content)
                            new_contents.append(" ")
                    child.clear()
                    child.extend(new_contents)
            item.set_content(soup.encode())
            contents = utils.parse_string(item.get_content())
            html.open_in_browser(contents)
            print('==================================')
    epub.write_epub('new_book.epub', book, {})

def translation_func(text):
    translator = Translator()
    result = translator.translate(text, dest='ru')
    return result.text

def main():
    open_epub()

if __name__ == "__main__":
    main()
В дополнение еще нужно отметить про файлы CSS, в книги их можно прочитать в файлах типа ITEM_STYLE = 2 или посмотреть в программе Sigil - EPUB Editor (https://sigil-ebook.com/) в заголовках элементов книги,
а находятся они в папке Styles.

<head>
  <title>Example book</title>
  <link href="../Styles/epub.css" rel="stylesheet" type="text/css"/>
  <link href="../Styles/syntax-highlighting.css" rel="stylesheet" type="text/css"/>
</head>

После перезаписи элементов книги ссылки на CSS в заголовке пропадают их можно вернуть с помощью программы Sigil - EPUB Editor (https://sigil-ebook.com/), нужно выбрать все элементы книги в папке text и правой кнопкой в контекстном меню выбрать "Связать с таблицей стилей…”.
Это все! Наша книга готова!
В заключении хочется сказать, что автоматизировать процессы - интересно, повышает общую эрудицию, учит работать с разными библиотеками, что называется залезть под “под капот”, да и просто разнообразить рутину.
Ссылки:
http://docs.sourcefabric.org/projects/ebooklib/en/latest/index.html#
https://beautiful-soup-4.readthedocs.io/en/latest/index.html?highlight=attrs#ulSoup/
https://py-googletrans.readthedocs.io/en/latest/
https://sigil-ebook.com/
http://docs.sourcefabric.org/projects/ebooklib/en/latest/index.html#
https://github.com/aerkalov/ebooklib/tree/master/samples#ebooklib-samples
http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.read_epub
http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.EpubBook
http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.EpubBook.get_items_of_type
http://docs.sourcefabric.org/projects/ebooklib/en/latest/ebooklib.html#ebooklib.epub.EpubItem
https://beautiful-soup-4.readthedocs.io/en/latest/index.html?highlight=attrs#ulSoup/
http://docs.sourcefabric.org/projects/ebooklib/en/latest/index.html#
https://sigil-ebook.com/
https://sigil-ebook.com/

###

Хабр (habr.com), 30.12.2022 11:46, Keithla, Пишем FastAPI с нуля на python
Теги: fastapi, python, asgi
https://habr.com/ru/post/708678/
Если вы здесь, то вероятно уже знаете, что такое FastAPI. Это простой в понимании, легковесный веб-фреймворк изначально созданный для создания API. Работает он с помощью ASGI-сервера, о котором можно почитать во многих статьях, здесь же мы только кратко затронем его.
И без лишних слов, сегодня, как ясно из названия, мы будем писать FastAPI. В двух словах, он построен на Starlette, который работает с ASGI, и на Pydantic, который позволяет производить автоматическую валидацию получаемых данных. FastAPI же очень удобная оболочка над ними.

Что в статье

* Рассмотрим приложение FastAPI, которое мы по итогу захотим запустить.
* Напишем FastAPI, с рабочим названием myfastapi.
* Запустим и проверим изначальное приложение написаное на fastapi с помощь myfastapi.

Что хотим написать

Все начинается с экземпляра главного класса FastAPI, который в свою очередь, во-первых наследуются от класса Starlette, который и выполняет всю основную работу по разрешению запросов, во-вторых создает декораторы, которые отправляют роуты в класс Starlette. Эти роуты хранятся там до запроса.
Когда происходит запрос к хосту на котором запущено приложение FastAPI, работая с ASGI фреймворком, приложение получает три параметра Scope, Receive и Send. Для работы ASGI приложению, точнее классу, нужен всего один метод __call__. Данный встроенный метод в классе FastAPI реализован лишь в виде вызова super().__call__, то есть класса Starlette. Но пока Starlette нас не интересует, до него мы еще дойдем.
В этой статье мы создадим функциональность, которая с помощью запуска ASGI сервера используя uvicorn main:app --reload, позволит работать следующему приложению

from typing import Union
from fastapi import FastAPI
from starlette.responses import JSONResponse
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

app = FastAPI()

@app.post("/items/{item_id}")
async def create_item(item: Item, item_id: int):
    return JSONResponse({"item": item.dict(), "item_id": item_id})

@app.get("/")
async def homepage():
    return JSONResponse({'hello': 'world'})

@app.get("/get_items/{item_id}")
async def read_item(item_id: int):
    print("item_id", item_id)
    return {"item_id": item_id}

Для этого нам сделать, во-первых, декораторы, которые будут оборачивать роуты с их данными и отправлять в класс, который будет их обрабатывать, во-вторых, получения параметров пути, параметров запроса, тела запроса и валидацию на соответствие типам, если они используются, будь то встроенные типы, типы из typing или даже pydantic, что и является основной чертой FastApi, автоматической проверкой типов получаемых данных.
Далее нам надо будет реализовать распределение запросов, то есть какой endpoint использовать при, например, GET запросе с путем “/items”. И в конце статьи, мы захотим сделать класс Response, который будет отлично работать в качестве ответа для ASGI сервера.
Конечно же, мы не будем использовать всю функциональность в рассматриваемых классах и методах, так как они могут охватывать большое количество путей использования. Поэтому будем использовать только необходимое, ведь когда мы это сделаем, то постепенно уже можно будет изучать и добавлять новую функциональность, доходя до реализации близкой к FastAPI. Если мы начнем охватывать все сразу, многое будет вызывать вопросы, но идя постепенно, код будет становититься все более понятным.

Пишем модуль myfastapi

Начнем с малого и самого простого - класс FastApi. Декораторы.

Как вы помните, инициализация простого приложения FastAPI, а возможно и большинства происходит следующим вызовом:

app = FastAPI()

Так как мы не будем рассматривать дебаггинг и OpenAPI здесь, то в метод __init__ мы просто добавим версию нашего приложения.
myfastapi::applications::FastApi::__init__

from typing import Callable
from starlette import Starlette
from myfastapi.routing import ApiRouter
 
class FastApi(Starlette):
    def __init__(
        self,
        version: str = "0.1.0"
    ) -> None:
        self.version = version
	  self.router: APIRouter = APIRouter()

Да, это все, что нам нужно здесь.
Сейчас посмотрим на то, что нас действительно интересует в этом классе - декораторы.
Мы видим класс ApiRouter, который мы будем использовать для создания декораторов, но об этом чуть позже.
На самом деле, как вы видите, наш класс FastApi не такой уж и простой в функциональности, так как он наследуется от класса Starlette, и это важно. На самом деле всю основную работу выполняет именно Starlette, а FastAPI просто удобная для использования оболочка над ним, но с довольно полезным функционалом и возможностью создания некоторого вида архитектуры для нашего приложения.
Итак, посмотрим на два метода get и post, которые используется в виде декораторов.
myfastapi::applications::FastApi::get

def get(
        self,
        path: str,
) -> Callable[..., Any]:
        return self.router.get(path)

myfastapi::applications::FastApi::post

def post(
        self,
        path: str,
) -> Callable[..., Any]:
        return self.router.post(path)

В двух словах, основной класс FastApi, который мы используем для создания приложения имеет под собой такой простой вызов методов класса ApiRouter.
Все, что мы передаем это путь, который будет запускать данный endpoint.
Становится очевидно, по тому, какой тип возврата указан у методов, что именно следующий вызов self.router.post(path) возвращает декоратор. Мы перейдем к классу ApiRouter уже скоро.
Так, помните, что для запуска ASGI приложения, необходимо, что класс был вызываемым, то есть имел метод __call__, и принимал три параметра Scope, Receive, Send. Где Scope отвечает за все метаданные и параметры пути, Receive хранит в себе тело запроса, а Send используется уже в самом конце обработки запроса для отправки заголовков и json ответа.
myfastapi::applications::FastApi::__call__

async def __call__(
self, scope: Scope, receive: Receive, send: Send
) -> None:
        await super().__call__(scope, receive, send)

Ага. Он просто вызывает класс Starlette, передавая ему полученные параметры.
Собственно, если использовать только два метода запроса get и post, так как для других методов используется идентичный подход, то класс FastApi для нашей библиотеки myfastapi, готов. Посмотрим на весь код вместе.
myfastapi::applications::FastApi

from typing import Callable
from starlette import Starlette
from myfastapi.routing import APIRouter
 
class FastApi(Starlette):
    def __init__(
        self,
        version: str = "0.1.0"
    ) -> None:
        self.version = version
    def get(
        self,
        path: str,
    ) -> Callable[..., Any]:
        return self.router.get(path)
    def post(
        self,
        path: str,
    ) -> Callable[..., Any]:
        return self.router.post(path)
    
    async def __call__(
        self, scope: Scope, receive: Receive, send: Send
    ) -> None:
        await super().__call__(scope, receive, send)

Точно, именно этот класс и будет использоваться для успешной инициализации нашего FastApi приложения.
Теперь пойдем дальше и перейдем в следующий файл routing.py, в котором у нас будет всего два класса ApiRouter и ApiRoute. Очевидно у них происходит определенное взаимодействие. ApiRouter действительно создает декораторы для методов запроса, возвращает из этих декораторы роуты, который представлены в виде класса ApiRoute, который в свою очередь содержит метод для проверки пути запроса и вызова endpoint если путь к экземпляре соответствующий, и по итогу, созданные из декораторов роуты или ApiRoute’s передаются в основной список роутов, в класс Router библиотеки starlette. И на этом работа FastApi с роутами заканчивается. А то, как проходить через них, какие методы вызывать у ApiRoute для соответствующих роутов остается на starlette.
Опять же, мы не будем лишний раз усложнять, и все добавляем постепенно. ApiRouter является классом для создания декораторов для функций, обрабатывающих запросы, и для передачи роутов к список, который хранится в starlette классе Routing, которые представлены классом ApiRoute состоящим из метода, пути, параметров и самой функции, то есть ApiRoute является оболочкой для определенного запроса.
Поэтому при инициализации ApiRouter мы без аргументов инициализируем класс Router от которого он наследуется, и просто добавим неинициализированный ApiRoute, который мы рассмотрим чуть позже, в переменную класса, для дальнейшей инициализации и использования при создании декоратора для определенного запроса.
myfastapi::routing::ApiRouter

from typing import Callable
from starlette.routing import Router, Any
 
class APIRouter(Router):
    def __init__(self) -> None:
        super().__init__()
        self.route_class = ApiRoute

Итак, следующий метод self.add_api_route будет принимать во-первых путь, который мы передадим в декоратор, например, @app.post("/items/"), во-вторых endpoint, то есть функцию, которая обрабатывает данные запрос, например:

async def create_item(item: Item):
    return JSONResponse(item.dict())

После чего эти данные будут использоваться для создания экземпляра класса ApiRoute, используя self.route_class, который будет сразу передаваться в список self.routes, находящийся в классе Routing (starlette).
myfastapi::routing::ApiRouter::add_api_route

def add_api_route(
        self,
        path: str,
        endpoint: Callable[..., Any],
	  method: str
) -> None:
	route = self.route_class(
    path, 
    endpoint=endpoint, 
    method=method
)
	self.routes.append(route)

Собственно это и есть главная функциональность данного класса. Теперь осталось сделать только декораторы для методов post и get (помните, что мы используем только их в этой статье?).
То есть, возвращаясь к классу FastApi, нам нужно сделать возможным следующее:
myfastapi::applications::FastApi::get

def get(
      self,
      path: str,
) -> Callable[..., Any]:
      return self.router.get(path)

И как вы догадываетесь, это очень просто:
myfastapi::routing::ApiRouter::get

def get(self, path: str) -> Callable[[Callable[..., Any]], [Callable[..., Any]]:
        def decorator(func: [Callable[..., Any]) -> [Callable[..., Any]:
	      self.add_api_route(path, func, method=”get”)
		return func
	  return decorator

Ничего необычного, простой декоратор, где func это наш endpoint для get запроса, и мы просто передаем путь и функцию для него в метод self.add_api_route, который мы рассмотрели выше. То есть таким простым способом мы регистрируем наши роуты в ASGI приложении.
И тоже самое для метода post
myfastapi::routing::ApiRouter::post

def post(self, path: str) -> Callable[[Callable[..., Any]], [Callable[..., Any]]:
        def decorator(func: [Callable[..., Any]) -> [Callable[..., Any]:
	      self.add_api_route(path, func, method=”post”)
		return func
	  return decorator

Мы также передаем и метод запроса, который используется для вызова функции для определенного пути, но в виде строки, хотя мы также могли бы привязать одну функцию для определенного пути для нескольких методов запроса. Просто будем иметь это ввиду.
Ну а сейчас, того, что есть в этом классе нам достаточно, посмотрим на весь получившийся класс:
myfastapi::routing::ApiRouter

from typing import Callable
from starlette.routing import Router, Any
 
class APIRouter(Router):
    def __init__(self) -> None:
        super().__init__()
        self.route_class = ApiRoute

    def add_api_route(
        self,
        path: str,
        endpoint: Callable[..., Any],
	  method: str
) -> None:
	route = self.route_class(
    path, 
    endpoint=endpoint, 
    method=method
)
	self.routes.append(route)

    def get(self, path: str) -> Callable[[Callable[..., Any]], [Callable[..., Any]]:
        def decorator(func: [Callable[..., Any]) -> [Callable[..., Any]:
	      self.add_api_route(path, func, method=”get”)
		return func
	  return decorator
 
    def post(self, path: str) -> Callable[[Callable[..., Any]], [Callable[..., Any]]:
        def decorator(func: [Callable[..., Any]) -> [Callable[..., Any]:
	      self.add_api_route(path, func, method=”post”)
		return func
	  return decorator

Да, так просто.
Теперь мы идем дальше, и уже начинается что-то интересное. Сейчас мы рассмотрим класс ApiRoute. Данный класс наследуется от starlette класса Route. И данный класс интересен нам тем, что он не просто является оболочкой, а переписывает поведение наследуемого класса. Вы наверное помните, что библиотека FastApi делает автоматическую валидацию типов для получаемых данных. Библиотека Starlette не поддерживает такую функциональность в своей основе, поэтому если бы вы использовали Starlette напрямую вместо FastApi, то вы могли бы присвоить своей функцию любую сигнатуру, то есть входящие переменные, присвоить им типы, но если в запросе могли бы прийти совершенно другие данные, и ошибка у вас возникла бы только при использовании заданных вами переменных функции, которая обрабатывает входящий запрос. FastApi же выдаст вам ошибку еще на этапе обработки полученных данных самой библиотекой, поэтому ваша функция даже не начнет работать, если входящие данные не соответствующие.
Собственно, данную функциональность в упрощенном виде, увеличивая ее функциональность в дальнейшем, мы будем реализовывать сейчас.
myfastapi::routing::ApiRoute

from starlette.routing import request_response
 
class ApiRoute(routing.Router):
    def __init__(
        self,
        path: str,
        endpoint: Callable[..., Any],
        method: str
    ) -> None:
        self.path = path
        self.endpoint = endpoint
        self.method = method
        assert callable(endpoint), "An endpoint must be a callable"
        self.dependant = get_dependant(path=self.path, call=self.endpoint)
        self.app = request_response(get_request_handler())

При инициализации ApiRoute мы видим несколько дополнительных функций, где get_dependant ключевая для нас сейчас, так как ее вызов зависимости для роута в виде параметров пути, запроса и тела, к которым присваиваются названия параметров, типы, является ли параметр обязательным, и дефолтное значение если нет. В двух словах, FastApi работает таким образом, что если вы не укажите дефолтное значение, при этом поставите тип Optional из typing, и не передадите этот параметр при вызове, то возникнет ошибка. Чтобы сделать параметр необязательным, вам нужно передать дефолтное значение.
Сейчас мы рассмотрим get_dependant, а к переменной self.app вернемся после.
myfastapi::dependencies::utils::get_dependant

def get_dependant(
    *,
    path: str,
    call: Callable[..., Any],
) -> None:
    path_param_names = get_path_param_names(path)
    endpoint_signature = inspect.signature(call)
    signature_params = endpoint_signature.parameters
    dependant = Dependant(call=call, path=path)
    for param_name, param in signature_params.items():
        param_field = get_param_field(
            param=param, param_name=param_name
        )
        if param_name in path_param_names: dependant.path_params.append(param_field)
        elif (lenient_issubclass(param_field.type_, (list, set, tuple, dict)) or
        lenient_issubclass(param_field.type_, BaseModel)
        ): dependant.body_params.append(param_field)
        else: dependant.query_params.append(param_field)

Пойдем по порядку. get_dependant принимает путь и endpoint запроса. get_path_param_names просто возвращает нам имена параметров, которые являются частью пути:
myfastapi::utils::get_path_param_names

def get_path_param_names(path: str) -> Set[str]:
    return set(re.findall("{(.*?)}", path))

inspect.signature позволяет получить сигнатуру функции, то есть ее параметры с названием, типом и дефолтным значением. Класс Dependant просто хранит все параметры, которые в дальнейшем при вызове определенного роута будут использоваться для валидации полученных параметров.
myfastapi::dependencies::models::Dependant

from typing import Any, Callable, List, Optional
from pydantic.fields import ModelField
 
class Dependant:
    def __init__(
        self,
        *,
        path_params: Optional[List[ModelField]] = None,
        query_params: Optional[List[ModelField]] = None,
        body_params: Optional[List[ModelField]] = None,
        call: Optional[Callable[..., Any]] = None,
        path: Optional[str] = None
    ) -> None:
        self.path_params = path_params or []
        self.query_params = query_params or []
        self.body_params = body_params or []
        self.call = call
        self.path = path

Вы можете видеть, что параметры хранятся в виде класса ModelField библиотеки pydantic. В документации FastApi написано, он основан на pydantic, что имеет смысл, так как вся валидация параметров, которые делает FastApi происходит с помощью pydantic. Именно мы поэтому мы будем оборачивать наши параметры в ModelField.
Итак, возвращаясь к get_dependant, для каждого параметра endpoint функции, который был получен с помощью выявления сигнатуры, происходит цикл, в котором параметр сначала становится инстансом класса ModelField

param_field = get_param_field(
            param=param, param_name=param_name
        )

после чего, выявляя, что это за параметр, добавляется в класс Dependant:

if param_name in path_param_names: dependant.path_params.append(param_field)
elif (lenient_issubclass(param_field.type_, (list, set, tuple, dict)) or
        lenient_issubclass(param_field.type_, BaseModel)
): dependant.body_params.append(param_field)
else: dependant.query_params.append(param_field)

Функция get_param_field возвращает инстанс ModelField для параметра, и выглядит она следующим образом:
myfastapi::dependencies::utils::get_param_field

from pydantic import BaseConfig
from pydantic.fields import ModelField, Undefined
 

def get_param_field(
    param: inspect.Parameter,
    param_name: str
) -> ModelField:
    default_value: Any = Undefined
    if not param.default == param.empty: default_value = param.default
    required = True
    if default_value is not Undefined: required = False
    annotation: Any = Any
    if not param.annotation == param.empty:
        annotation = param.annotation
    field = ModelField(
        name=param_name,
        type_=annotation,
        default=default_value,
        class_validators=None,
        required=required,
        model_config=BaseConfig,
    )
     
    return field

В get_param_field мы сначала делаем проверку на дефолтное значение, если оно присутствует, значит обозначаем параметр как необязательный, добавляем аннотацию, то есть тип параметра, и инициализируем ModelField с нашими и необходимыми параметрами.
При проверке, в какой список класса Dependant добавить данный инстанс параметра:

if param_name in path_param_names: dependant.path_params.append(param_field)
elif (lenient_issubclass(param_field.type_, (list, set, tuple, dict)) or
        lenient_issubclass(param_field.type_, BaseModel)
): dependant.body_params.append(param_field)
else: dependant.query_params.append(param_field)

Если название параметра в path_param_names, то есть он является частью пути, то он добавляется в path_params, если параметр является подклассом одной из четырех коллекций или BaseModel от pydantic, например:

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

то данный параметр добавляется в список body_params, и соответственно, если параметр не является ни частью пути, ни тела запроса, то он добавляется в query_params и расматривается как параметр пути, который указывается после “?” в запросе.
Отлично! Наши зависимости разрешены, и мы можем запускать приложение в режиме --reload. Они будут сидеть и ждать своей очереди на использование до запроса, который бы вызывал endpoint к которому вместе с путем определенный Dependant и относится.
Все, что нам осталось сделать, это добавить методы для обработки запросов, и для этого мы возвращаемся к классу ApiRoute:
myfastapi::routing::ApiRoute

from starlette.routing import request_response
 
class ApiRoute(routing.Router):
    def __init__(
        self,
        path: str,
        endpoint: Callable[..., Any],
        method: str
    ) -> None:
        self.path = path
        self.endpoint = endpoint
        self.method = method
        assert callable(endpoint), "An endpoint must be a callable"
        self.dependant = get_dependant(path=self.path, call=self.endpoint)
        self.app = request_response(get_request_handler(dependant=self.dependant))

Сейчас нам надо вспомнить то, о чем мы говорили в контексте ASGI приложения.
Чтобы обработать запрос ASGI приложения, запущенного, например с помощью uvicorn нужно следующее:

async def app(scope, receive, send):
    """
    Echo the request body back in an HTTP response.
    """
    body = await read_body(receive)
    await send({
        'type': 'http.response.start',
        'status': 200,
        'headers': [
            [b'content-type', b'text/plain'],
        ]
    })
    await send({
        'type': 'http.response.body',
        'body': body,
    })

То есть приложение должно принять три параметра - scope, receive, send. Где scope это данные о запроса, включая путь, receive это тело запроса, а send метод для отправки ответа.
Но нам не нужно в статье, рассматривающей FastApi писать это с нуля, так как приемом запроса и отправкой ответа занимается starlette, нам, что и делает FastApi, нужно лишь использовать соответствующие классы.
Так вот, в нашем коде, в методе инициализации класса ApiRoute функция request_response, которая, из названия ясно, используется одновременно и для обработки request, и для отправки response, принимает пользовательскую функцию, которая принимает обработанный request с помощью класса Request от starlette, и возвращает функцию или класс response, который при вызове __call__ принимает три ASGI параметра, описанных выше, и использует await send для отправки ответа, что у нас благодаря starlette уже есть, а именно класс Response.
Соответственно, наша функция get_request_handler:

self.app = request_response(get_request_handler(dependant=self.dependant))

должна быть такой, как описано выше.
Давайте взглянем на нее.
myfastapi::routing::get_request_handler

def get_request_handler(
    dependant: Dependant,
) -> Callable[[Request], Coroutine[Any, Any, Response]]:
    is_coroutine = asyncio.iscoroutinefunction(dependant.call)
    async def app(request: Request) -> Response:
	  body = None
        if dependant.body_params:
            body = await request.json()
            буду
      solved_result = await solve_dependencies(
            request=request,
            dependant=dependant,
            body=body
            )
        values, errors = solved_result
        if errors: raise ValidationError(errors, RequestErrorModel)

        raw_response = await run_endpoint_function(
                dependant=dependant, values=values, is_coroutine=is_coroutine
            )
        if isinstance(raw_response, Response): return raw_response
	  if isinstance(raw_response, (dict, str, int, float, type(None))):
            return JSONResponse(raw_response)
        else: raise Exception("Type of response is not supported yet.")

    return app

Итак, get_request_handler принимает созданный нами ранее dependant для роута, после чего проверяет на асинхронность endpoint для роута, который хранится в переменной call у dependant.
Функция app будет использоваться во время запроса к роуту, в котором она находится. Функциональность данной функции во время запроса выглядит следующим образом. Сначала она получает тело запроса с помощью json функции класса Request от starlette, после чего, вызывает функцию solve_dependencies, которая производит валидацию полученных параметров, и возвращает необходимые значения для сигнатуры endpoint и ошибки, если они были получены при валидации. Если ошибок нет, то вызывается наша оригинальная функция run_endpoint, которая используя полученные значения параметров из запроса вызывает endpoint, который и возвращает response. Данный response как уже было описано выше, должен принимать ASGI параметры и отправлять ответ. И данный ответ, легко можно сделать, просто обернув наш ответ, например JsonResponse от starlette.
Теперь давайте рассмотрим solve_dependencies, а именно то, как она производит валидацию параметров.
myfastapi::dependencies::utils::solve_dependencies

async def solve_dependencies(
    *,
    request: Request,
    dependant: Dependant,
    body: Dict[str, Any],
) -> Tuple[Dict[str, Any], List[ErrorWrapper], Response]:
    values: Dict[str, any] = {}
    errors: List[ErrorWrapper] = []
  
    path_values, path_errors = request_params_to_args(
        dependant.path_params, request.path_params
    )
    query_values, query_errors = request_params_to_args(
        dependant.query_params, request.query_params
    )
    values.update(path_values)
    values.update(query_values)
    errors += path_errors + query_errors

    if dependant.body_params:
        (
            body_values,
            body_errors,
        ) = await request_body_to_args(  # body_params checked above
            required_params=dependant.body_params, received_body=body
        )
        values.update(body_values)
        errors.extend(body_errors)
    return values, errors

Вот наконец-то мы видим где используется dependant. Используя две довольно похожие функции request_params_to_args и request_body_to_args, которые принимают ожидаемые параметры, которые хранятся в списках класса Dependant в виде экземпляров класса ModelField от pydantic, магию которого мы увидим в этих методах, и полученные параметры, которые любезно достаются из scope классом Request от starlette, и body, который мы уже достали в get_request_handler.
Посмотрим сначала на request_params_to_args
myfastapi::dependencies::utils::request_params_to_args

from pydantic.error_wrappers import ErrorWrapper
from pydantic.errors import MissingError
 

def request_params_to_args(
    required_params: Sequence[ModelField],
    recieved_params: Union[Mapping[str, Any], QueryParams]
) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:
    values: Dict[str, Any] = {}
    errors: List[ErrorWrapper] = []
    for field in required_params:
        value = recieved_params.get(field.alias)
        if value is None:
            if field.required:
                errors.append(ErrorWrapper(
                    MissingError(),
                    loc=field.alias)
                    )
            else: values[field.name] = deepcopy(field.default)
            continue

        v_, errors_ = field.validate(value, values, loc=field.alias)

        if isinstance(errors_, ErrorWrapper):
            errors.append(errors_)
        elif isinstance(errors_, list):
            errors.extend(errors_)
        else:
            values[field.name] = v_
    return values, errors

Здесь происходит следующее: мы проходим циклом по каждому параметру, который нам требуется для endpoint, после чего используя переменную alias, значение которой, это имя параметра, мы пытаемся получить значение для данного параметра из объекта полученных параметров для запроса. Если значения для параметра нету и он является обязательным, то список ошибок добавляется MissingError, если он необязательный и значения нет, то просто копируется дефолтное значение и цикл переходит к следующему параметру.
Если же значение есть, то, храня параметр со всеми его данными в виде экземпляра класса ModelField от pydantic, нам всего лишь нужно вызвать метод validate с полученным значениями, которые вернет значение для параметра и ошибки если они возникли при валидации.
Соответственно, используя request_params_to_args, мы проверяем параметры пути и запроса:

    path_values, path_errors = request_params_to_args(
        dependant.path_params, request.path_params
    )
    query_values, query_errors = request_params_to_args(
        dependant.query_params, request.query_params
    )
    values.update(path_values)
    values.update(query_values)
    errors += path_errors + query_errors

Теперь посмотрим на похожий метод request_body_to_args.
myfastapi::dependencies::utils::request_body_to_args

async def request_body_to_args(
    required_params: List[ModelField],
    received_body: Union[Dict[str, any], None],
) -> Tuple[Dict[str, any], List[ErrorWrapper]]:
    values: Dict[str, Any] = {}
    errors: List[ErrorWrapper] = []
    if required_params:
        field_alias_omitted = len(required_params)
        if field_alias_omitted == 1:
            field = required_params[0]
            received_body = {field.alias: received_body}
      
        for field in required_params:
            if field_alias_omitted:
                loc = ("body",)
            else:
                loc = ("body", field.alias)
            value: Optional[Any] = None
            if received_body is not None:
                try: value = received_body.get(field.alias)
                except AttributeError:
                    errors.append(ErrorWrapper(MissingError(), loc=loc))
                    continue
            if value is None:
                if field.required: errors.append(ErrorWrapper(MissingError(), loc=loc))
                else: values[field.name] = deepcopy(field.default)
                continue

            v_, errors_ = field.validate(value, values, loc=loc)

            if isinstance(errors_, ErrorWrapper):
                errors.append(errors_)
            elif isinstance(errors_, list):
                errors.extend(errors_)
            else:
                values[field.name] = v_
    return values, errors

Как мы видим, здесь практически все тоже самое как и в request_params_to_args, только теперь мы проверяем количество необходимых параметров в теле запроса, и идем циклам по ним.
Соответственно, мы используем функцию request_body_to_args, если список body_params класса Dependant, который хранит необходимые параметры для тела запроса, выявленные с помощью инспектирования сигнатуры endpoint, является не пустым.

if dependant.body_params:
        (
            body_values,
            body_errors,
        ) = await request_body_to_args(  # body_params checked above
            required_params=dependant.body_params, received_body=body
        )
        values.update(body_values)
        errors.extend(body_errors)
    return values, errors

Полученные значения и ошибки возвращаются в функцию get_request_handler для дальнейшего использования:

  solved_result = await solve_dependencies(
              request=request,
              dependant=dependant,
              body=body
              )
  values, errors = solved_result
  if errors: raise ValidationError(errors, RequestErrorModel)
  
  raw_response = await run_endpoint_function(
          dependant=dependant, values=values, is_coroutine=is_coroutine
      )

Теперь, имея полученные данные, которые прошли валидацию, мы можем запустить endpoint роута используя функцию run_endpoint_function:

async def run_endpoint_function(
    *, dependant: Dependant, values: List[str, Any], is_coroutine: bool
) -> Any:
    assert dependant.call is not None, "dependant.call must be a function"

    if is_coroutine:
        return await dependant.call(**values)
    else:
        return await run_in_threadpool(dependant.call, **values)

В ней мы проверяем, если endpoint является асинхронным, то запускаем его в обычном await, если же нет, мы используем функцию run_in_threadpool от starlette, чтобы запустить endpoint в асинхронном режиме, не блокируя event loop.
И сейчас, после того, как наш endpoint отработал и вернул ответ, нам нужно проверить, что это за ответ:

if isinstance(raw_response, Response): return raw_response
if isinstance(raw_response, (dict, str, int, float, type(None))):
    return JSONResponse(raw_response)
else: raise Exception("Type of response is not supported yet.")

Что здесь происходит? Сперва мы проверяем, является ли ответ экземпляром класса Response от starlette, который имеет всю необходимую функциональность для отправки ответа ASGI приложению.
Для этого нужно импортировать класс JSONResponse:

from starlette.responses import JSONResponse

и использовать его для создания ответа в endpoint

@app.post("/items/{item_id}")
async def create_item(item_id: int):
    return JSONResponse({"item": item_id})

У нас, в случае если ответ, это dict или простой тип, то мы просто оборачиваем их в JSONResponse, но у FastApi идет более сложная обработка, так, что нужно понять, это, используя класс JSONResponse в вашем пользовательском endpoint вы увеличиваете скорость ответа вашего приложения, что может быть очень важно. Также, если вы снова обратите внимание на run_endpoint_function, то поймете, что сразу делая endpoint асинхронным, вы также сокращаете время обработки.
Вот так вот, понимая внутреннее устройство, можно увеличить производительность вашего FastApi приложения - используйте асинхронность и Response от starlette для создания ваших endpoint’s.
Собственно вот, мы рассмотрели, как сделать простое FastApi приложение с нуля. Но как вы поняли, это совсем не с нуля. FastApi построен не на pydantic, как это указано в документации, а полностью на starlette.

Запускаем наше приложение

Все, что нам нужно сделать, это в первом куске кода в начале статьи заменить импорт главного класса, из которого создается приложение:

from typing import Union

from myfastapi.applications import FastAPI
from starlette.responses import JSONResponse
from pydantic import BaseModel

class Item(BaseModel):
    name: str
    description: Union[str, None] = None
    price: float
    tax: Union[float, None] = None

app = FastAPI()

@app.post("/items/{item_id}")
async def create_item(item: Item, item_id: int):
    return JSONResponse({"item": item.dict(), "item_id": item_id})

@app.get("/")
async def homepage():
    return JSONResponse({'hello': 'world'})

@app.get("/get_items/{item_id}")
async def read_item(item_id: int):
    return {"item_id": item_id}

Просто используйте следующую команду:

uvicorn main:app --reload

Теперь вы можете протестировать эти API's с помощью, например, Postman.
Исходный код (https://github.com/Nikitala0014/myfastapi)
Удачи!
Ссылки:
https://github.com/Nikitala0014/myfastapi

###

Хабр (habr.com), 29.12.2022 22:24, OlegSivchenko, Тринитит — стеклянные слёзы атомного века
Теги: атомная бомба, манхэттенский проект, геохимия, космос
https://habr.com/ru/post/708568/
«Если сияние тысячи солнц вспыхнуло бы в небе, это было бы подобно блеску Всемогущего…-Я стану смертью, Разрушителем Миров».
Эти слова произнёс Роберт Оппенгеймер 16 июля 1945 года, после того, как в 5.29 на полигоне Аламогордо в Нью-Мексико была испытана первая атомная бомба под кодовым названием «Gadget» («Штуковина»). Заряд располагался внутри специально возведённой тридцатиметровой башни, а физики и генералы наблюдали за взрывом из бункера. Само испытание называлось «Тринити».
Именно тогда, в 5.29 утра по местному времени, на Земле впервые образовался новый минерал – стеклопесок, оставшийся на месте взрыва. Кристаллы минерала получились красноватыми и зеленоватыми из-за включений радиоактивных металлов. Новое вещество назвали «тринитит».
Оказывается, тринитит имеет не только научную, но и коллекционную, и даже художественную ценность. Ниже я кратко расскажу о свойствах, изучении и применении этого минерала.

История, физика и химия тринитита

Манхэттенский проект позволил чуть более чем за три года (июнь 1942 – июль-август 1945) создать ядерное оружие и применить его. Размах Манхэттенского проекта был не менее беспрецедентным, чем скорость реализации – он потребовал создать совершенно новые научные методы (например, метод Монте-Карло (https://ru.wikipedia.org/wiki/Метод_Монте-Карло#Рождение_метода_Монте-Ка�%)) и даже отрасли тяжёлой промышленности (газовая диффузия (https://ru.wikipedia.org/wiki/Газовая_диффузия)). Поводом к планированию проекта можно считать письмо (http://www.famhist.ru/famhist/bomb/00014ed3.htm) Эйнштейна Рузвельту от 2 мая 1939 года – впрочем, в тот момент недооценённое. Как бы то ни было, Манхэттенский проект позиционировался как экстренный НИОКР, призванный «догнать» немецкую ядерную программу, во главе которой стояли Гейзенберг и Ган, но к окончанию войны в Европе завершён не был (немецкий ядерный проект не окончился вообще ничем). Тем не менее, ядерная бомбардировка должна была представляться США логичной как с точки зрения оправдания затраченных расходов, так и потому, что именно Япония вероломно напала на США в 1941 году и на протяжении всей войны была основным соперником американцев. Но испытание «Тринити» в большей степени было физикой и геополитикой, чем подготовительным актом к военной операции. Что касается физики – к июлю 1945 года уже было известно, что организовать промышленную наработку плутония для имплозивных бомб модели  «Толстяк» (https://strana-rosatom.ru/2021/06/18/kak-vyglyadeli-pervye-atomnye-bomby/) гораздо проще, чем добывать методом газовой диффузии редчайший уран-235. По этим причинам в Нью-Мексико был взорван именно «Толстяк», а не «Малыш», и это была первая неуправляемая ядерная реакция на Земле, как минимум, за последние полтора миллиарда лет (https://habr.com/ru/post/568184/). При возникших на месте испытания звёздных температурах и давлениях, естественно, образовался минерал, которого на Земле прежде не существовало. Его называли «атомзит» и «стекло из Аламогордо», но прижилось именно название тринитит (https://www.techcult.ru/science/11105-nevozmozhnye-kvazikristally).

Точная физическая картина событий, происходящих в гипоцентре ядерного взрыва, не известна до сих пор – равно как и показатели температуры и давления, при которых образуется тринитит. По всей видимости, образование тринитита зависит не только от мощности, но и от скорости протекания процессов – важно, чтобы «околосолнечные» температуры и давление быстро возникали и столь же быстро спадали. Температура плавления (https://wotakks.ru/pro-beton/plavlenie-peska.html) кварцевого песка – 2300 ⁰С, а температура кипения (https://znanija.com/task/21733769) – около 3000 ⁰С. При образовании тринитита, очевидно, также происходит конденсация песка, плутония и металлических примесей. Песок превратился в тринитит в радиусе от 300 до 800 метров от гипоцентра взрыва.
Тринитит – один из семейства подобных минералов, которые образуются при атомном взрыве и выпадают из грибовидного облака в виде осадков. Кроме тринитита известны хиросимиты (Хиросима) и харитончики (Семипалатинск), а также чернобылит – минерал схожего генеза, сформировавшийся после аварии на Чернобыльской АЭС. Тринитит и схожие с ним минералы (далее, если явно не указано иное, речь идёт именно о тринитите) представляют собой стекловидные минералы с включением силикатов и металлов. На состав и твёрдость таких минералов влияют свойства песка (грунта) в точке взрыва, в частности, содержание кварца и размер песчинок. В состав тринитита всегда входит плутоний, а также могут входить железо, медь, кобальт и иногда – другие металлы.

Кратер на месте взрыва «Тринити» исследовался с первых дней после испытания, но внимание уделялось, в основном, баллистическим аспектам и остаточной радиоактивности, а не геологии и петрохимии «точки зеро». По-видимому, первая публикация с анализом состава тринитита вышла (http://www.minsocam.org/ammin/AM33/AM33_360.pdf) в 1948 году, и автором её был Кларенс Росс. Вот как он описал этот минерал:
«Это стекло образовало слой толщиной 1-2 сантиметра. В верхней части отмечается очень тонкий слой пыли, осевшей на минерал, когда он ещё был расплавлен. Нижняя часть – более толстый слой частично сплавившихся веществ, постепенно переходящий в грунт, на котором минерал образовался. Цвет стекла бледно-зелёный, а сам материал крайне зернист, причём, некоторые пузырьки могут распространяться на всю толщину образца. Минерал образовался из аркозового песка, включающего зёрна кварца, большое количество полевого шпата (как микроклиновые, так и, в меньшем количестве, плагиоклазовые варианты). Также содержит небольшие количества кальцитов, роговой обманки и авгита в суглинковой подложке. Эти материалы образовали стекло двух различных типов. Глины, полевой шпат и сопутствующие минералы очень плавкие и должны характеризоваться высокой мобильностью».
Таким образом, тринититы крайне неоднородны, но радиологи и военные не обращали внимания на эти детали и считали тринитит гомогенным веществом. Росс, в свою очередь, не учёл антропогенных примесей в минерале, а именно – плутония и азотистых включений, оставшихся от тротила (в частности, нитрата бария). Из антропогенных материалов подробнее остановимся на плутонии. В атомной бомбе (как плутониевой, так и урановой) для запуска ядерной реакции необходима критическая масса активного вещества (https://www.mirf.ru/science/kak-sdelat-atomnuyu-bombu/). Приемлемое значение – около 64 кг урана-235 («Малыш») или несколько килограммов плутония-239 («Толстяк»). В устройстве, взорванном в Нью-Мексико, было примерно 6 кг плутония-239. Инициирующим изотопом, благодаря которому реакция не затухает, а становится цепной, в данном случае был плутоний-240. Содержание плутония-240 может варьироваться, но при испытании «Тринити» составляло 6-7%. Такой процент изотопа 240 не только означает, что данный образец плутония является оружейным, но и позволяет выяснить его происхождение. Естественно, плутоний из «Тринити» был произведён в Хэнфорде, штат Теннеси – на единственном заводе по обогащению ядерного топлива, существовавшем в то время. При этом ещё в 1943 году плутоний-239 был получен (http://www.famhist.ru/famhist/hal/0009dea0.htm) на ленинградском циклотроне Игорем и Борисом Курчатовыми. Соответственно, доля плутония-240 в образце тринитита позволяет установить, до какой степени этот плутоний был обогащён и где именно получен

Тринитит и квазикристаллы

Возможно, в ходе испытания «Тринити» также были получены первые квазикристаллы. Ранее я упоминал о вероятной геометрической структуре квазикристаллов в статье «Змей и дротик (https://habr.com/ru/post/582330/)», посвящённой апериодическим мозаикам Пенроуза. Собственно, основная особенность квазикристаллов заключается в апериодичности их решётки:

Точные условия для образования квазикристаллов также неизвестны, но, согласно работам Дана Шехтмана, в 1982 году удостоенного Нобелевской премии по физике (https://www.chemistryworld.com/3004748.article) за исследования квазикристаллов, высокие температуры и высокое давление явно способствуют формированию апериодической кристаллической решётки. Именно это наблюдение побудило геолога Люку Бинди (https://www.sites.google.com/view/luca-bindi/) из Флорентийского университета и физика Пола Стейнхардта (https://paulsteinhardt.org/) из Принстонского университета поискать квазикристаллы в тринитите. Пол Стейнхардт (род. 1952) наряду с Шехтманом – пожалуй, крупнейший специалист по квазикристаллам в мире.
На Хабре выходила статья (https://habr.com/ru/company/digitaloctober/blog/139469/) Юлии Щукиной @lesnikova (/users/lesnikova) о том, как Стейнхардт совместно с российскими геологами открыл первый естественный квазикристаллический минерал хатыркит на Чукотке (возможно, хатыркит имеет метеоритное происхождение). Квазикристалл хатыркита имеет форму, близкую к икосаэдру и химическую формулу (Al62Cu24Fe13).
В 2021 году Бинди и Стейнхардт опубликовали статью (https://paulsteinhardt.org/wp-content/uploads/2021/05/BindiEtalTrinitite.pdf) о новом икосаэдрическом квазикристалле найденном в образце тринитита длиной 1 см. Проверить этот экзотический минерал на наличие квазикристаллов учёные решили ещё и потому, что открытый в 2010 году хатыркит имеет импактную (ударную) природу. Большинство синтетических квазикристаллов – это полиметаллические сплавы. И действительно, методом рентгеновской дифракции удалось выявить в образце тринитита 12 «металлических капелек» с квазикристаллической структурой и формулой Si61Cu30Ca7Fe2.

Тея и Луна

На Хабре также писали (https://habr.com/ru/post/373189/) о том, что крупнейшее импактное событие в истории Земли могло произойти в глубокой древности, когда во внутренней части Солнечной системы ещё находилось множество планетезималей (https://habr.com/ru/company/timeweb/blog/663790/). В тот период (более 4 миллиардов лет назад) Земля могла столкнуться с объектом, размеры которого были примерно как у Марса. Этот гипотетический объект называют Тея. Осколки от столкновения впоследствии сконцентрировались на орбите Земли и образовали Луну. При этом часть земных пород и пород Теи, должна была испариться и (учитывая вероятный железо-силикатный состав обоих тел) выпасть в виде стекловидных осадков. На Земле с тех пор шли активные геологические процессы, поэтому следов столкновения не осталось, а вот на поверхности Луны в составе реголита должны встречаться минералы, похожие на тринитит.
Проверить эту гипотезу (https://sci-hub.ru/10.1126/sciadv.1602668) в 2017 году решил физик Джеймс Дэй из университета Сан-Диего. Он предположил, что испытание «Тринити» можно считать миниатюрной моделью соударения Земли и Теи. В таком случае как в тринитите, так и в лунном реголите должен был бы наблюдаться дефицит переходных металлов, в особенности, цинка – поскольку при рассматриваемых температурах цинк переходит в летучую форму и рассеивается далеко от места взрыва. Более того, природный цинк содержит 5 стабильных изотопов (64Zn, 66Zn, 67Zn, 68Zn, и 70Zn), и чем тяжелее изотоп – тем меньше он должен был бы рассеиваться при взрыве. Оказалось, что в разных образцах тринитита, взятых на расстоянии от 10 до примерно 200 м от места взрыва доля цинка-66 действительно стабильно падает от 0,25 до 0,2 промилле, и тринитит измеримо беднее цинком, чем окружающие песчаниковые породы. Схожие закономерности содержания цинка (преобладание тяжёлых изотопов над лёгкими) характерны (https://sci-hub.ru/https:/doi.org/10.1038/nature11507) и для лунного грунта. Более того, в лунном грунте наблюдается схожая картина с изотопами никеля, а также практически отсутствует вода, мгновенно переходящая в летучую форму при импактных событиях. Если в обозримом будущем нам суждено высадиться на Луне, то было бы особенно интересно поискать там стекловидные породы или аналоги тринитита.

Заключение

После 1952 года свободный сбор тринитита в Нью-Мексико запрещён, а значительная часть радиоактивного грунта захоронена. Но уже в конце 1945 года предприимчивый дизайнер Марк Ковен принялся рекламировать тринитит как эстетичный поделочный камень (https://www.atlasobscura.com/articles/trinitite-trinity-test-mineral-cultural-jewelry), умело вкрапляя его в серьги, броши и браслеты собственного производства. В последующий период доступ на место взрыва был открыт для массовой публики всего два дня в году, но даже при таком ограничении тринитит собирали подчистую. Особенно ценились чёрные образцы, в которых осталось железо от металлоконструкций тестовой вышки, а также красноватые, в которых заключена медь из проводов. Сегодня тринитит собирают преимущественно в научных и сталкерских целях, поскольку известно, насколько он радиоактивен и опасен. Я же считаю тринитит по-настоящему красивым и завораживающим минералом и специально приберёг пост о нём на последние часы уходящего года. Надеюсь, что в обозримом будущем это удивительное вещество так и останется геохимической и коллекционной экзотикой, а не будет тоннами пылиться по всему северному полушарию.
Ссылки:
https://ru.wikipedia.org/wiki/Метод_Монте-Карло#Рождение_метода_Монте-Ка�%
https://ru.wikipedia.org/wiki/Газовая_диффузия
http://www.famhist.ru/famhist/bomb/00014ed3.htm
https://strana-rosatom.ru/2021/06/18/kak-vyglyadeli-pervye-atomnye-bomby/
https://habr.com/ru/post/568184/
https://www.techcult.ru/science/11105-nevozmozhnye-kvazikristally
https://wotakks.ru/pro-beton/plavlenie-peska.html
https://znanija.com/task/21733769
http://www.minsocam.org/ammin/AM33/AM33_360.pdf
https://www.mirf.ru/science/kak-sdelat-atomnuyu-bombu/
http://www.famhist.ru/famhist/hal/0009dea0.htm
https://habr.com/ru/post/582330/
https://www.chemistryworld.com/3004748.article
https://www.sites.google.com/view/luca-bindi/
https://paulsteinhardt.org/
https://habr.com/ru/company/digitaloctober/blog/139469/
/users/lesnikova
https://paulsteinhardt.org/wp-content/uploads/2021/05/BindiEtalTrinitite.pdf
https://habr.com/ru/post/373189/
https://habr.com/ru/company/timeweb/blog/663790/
https://sci-hub.ru/10.1126/sciadv.1602668
https://sci-hub.ru/https:/doi.org/10.1038/nature11507
https://www.atlasobscura.com/articles/trinitite-trinity-test-mineral-cultural-jewelry

###

Хабр (habr.com), 02.01.2023 14:50, lawxls, Лучшие open-source инструменты для Python проектов
Теги: open-source, Django, Python, Flask, FastAPI, developer experience, pre-commit
https://habr.com/ru/post/708916/
"Give me six hours to chop down a tree and I will spend the first four sharpening the axe."
Open-source проекты, сторонние инструменты и библиотеки - это то, за что мы действительно любим Python. В этой статье я собрал самые полезные, валидированные сообществом и проверенные временем инструменты, конфигурации которых можно встретить в популярных проектах с открытым исходным кодом.
Инструменты распределены по этапам/сферам разработки. По каждому из них я дам небольшое описание и попытаюсь рассказать о его пользе. Если утилита имеет дополнительные расширения/плагины, то я расскажу про самые полезные (на мой взгляд).

Личный проект

Как пример интеграции инструментов из этой статьи, можно открыть репозиторий (https://github.com/lawxls/HackerNews-Alerts-Bot) с исходным кодом моего проекта. HackerNews Alerts Bot (GitHub (https://github.com/lawxls/HackerNews-Alerts-Bot)) - Telegram-бот для получения различных уведомлений с форума Hacker News (https://news.ycombinator.com/). Помимо просмотра конфигураций, чтобы быть в курсе актуальных новостей и статей, можно запустить этот бот и подписаться на уведомления о новых постах по ключевому слову. Например, чтобы подписаться на посты о Python, введите: /add python -stories.

Список инструментов

* Конвейер интеграции
* 1.1 pre-commit
* Управление зависимостями
* 2.1 pip-compile
* Качество кода
* 3.1 flake8
* 3.2 Black
* 3.3 isort
* 3.4 Mypy
* 3.5 Ruff: замена flake8 и isort
* Тестирование
* 4.1 pytest
* Дебаггинг
* 5.1 PySnooper
* Терминал
* 6.1 IPython
* 6.2 Rich


1. Конвейер интеграции

Чтобы успешно интегрировать инструменты из этой статьи в Python проект нам необходима надежная система, которая возьмет на себя работу по их установке, обновлению и запуске при наступлении определенного события. State of the art инструментом в этой категории безусловно является pre-commit.


1.1 pre-commit

pre-commit (https://github.com/pre-commit/pre-commit) — это фреймворк, использующий git pre-commit hook для запуска хуков (инструментов) перед созданием коммита. Помимо запуска инструментов, pre-commit также берет на себя их установку и обновление.
pre-commit пользуется большой популярностью среди open-source Python проектов, например .pre-commit-config.yaml может быть найден в репозиториях наиболее популярных веб-фреймворков: Django, Flask и FastAPI. Это тот самый инструмент, конфиг которого я добавляю первым в новый проект.
Гайд по установке, Quick start и другая полезная информация доступна в документации (https://pre-commit.com/#installation).
В следующем разделе я расскажу о расширениях, которые обязательно пригодятся в вашей конфигурации. Хуки инструментов из этой статьи указаны в разделе «pre-commit хук» соответствующей утилиты.

Полезные хуки

Стандартная конфигурация уже имеет некоторые расширения из pre-commit-hooks репозитория (https://github.com/pre-commit/pre-commit-hooks). Кроме того, репозиторий содержит достаточное количество готовых хуков, которые можно легко добавить в .pre-commit-config.yaml.
pyupgrade
pyupgrade (https://github.com/asottile/pyupgrade) — это хук от создателя pre-commit для автоматического обновления синтаксиса языка. Например, pyupgrade перепишет простые вызовы str.format() в f-strings.
Добавить расширение в конфиг pre-commit:

-   repo: <https://github.com/asottile/pyupgrade>
    rev: v3.3.1
    hooks:
    -   id: pyupgrade

typos
typos (https://github.com/crate-ci/typos) — spell-checker, написанный на rust, для проверки исходного кода. Хук отличается высокой скоростью проверки и минимальным количеством ложных срабатываний.

-   repo: <https://github.com/crate-ci/typos>
    rev: v1.13.4
    hooks:
    -   id: typos

Документация (https://pre-commit.com/#installation)
Репозиторий (https://github.com/pre-commit/pre-commit)
pre-commit-hooks (https://github.com/pre-commit/pre-commit-hooks)
pyupgrade (https://github.com/asottile/pyupgradehttps://github.com/asottile/pyupgrade)
typos (https://github.com/crate-ci/typos)

2. Управление зависимостями

С управлением зависимостей в Python не все однозначно. Poetry, pipenv, conda - все эти библиотеки являются популярным выбором среди пользователей языка. Моя причина выбора pip-compile довольно-таки проста: pip-compile позволяет мне пользоваться стандартными инструментами (venv и pip), решая основные проблемы управления зависимостями. Ни больше ни меньше.

2.1 pip-compile

Зачем нужен pip-compile?

Перечислю несколько проблем, возникающих при заморозке зависимостей с помощью pip freeze:

* Нельзя определить, откуда взялась какая-либо из зависимостей, так как
* pip freeze
* сохраняет все вперемешку (Пакеты, от которых наш проект зависит напрямую, и зависимости этих пакетов).
* Добавляя новый пакет в
* requirements.txt
* , мы не фиксируем его собственные зависимости. Новые версии этих незакрепленных библиотек могут привести к трате времени на дебаггинг таких обновлений.
* Редактирование версии пакета в
* requirements.txt
* оставляет без внимания зависимости этой библиотеки. Новые пакеты не добавляются, а старые - не удаляются, что снова приводит к проблемам на этапе сборки.

Для решения этих проблем нам нужно хранить два файла с зависимостями. Первый файл (requirements.in) будет содержать пакеты, которые мы будем добавлять вручную. Во втором файле (requirements.txt) будут храниться закрепленные версии каждой библиотеки нашего проекта, включая пакеты, добавленные вручную (и их зависимости). Список библиотек requirements.in нужен для генерации второго файла, того самого requirements.txt, который мы используем при сборке проекта.
pip-compile - это инструмент, с помощью которого можно осуществить такой подход управления зависимостями.

Управление зависимостями с помощью pip-compile

pip-compile - это одна из утилит пакета pip-tools (https://github.com/jazzband/pip-tools), поэтому, чтобы начать им пользоваться, установим эту библиотеку (PyPI (https://pypi.org/project/pip-tools/)).
После установки пакета создайте файл requirements.in. Сюда мы будем добавлять зависимости напрямую, например:
Flask
Теперь можно вызвать pip-compile. Эта команда генерирует итоговый requirements.txt файл:

$ pip-compile
#
# This file is autogenerated by pip-compile with Python 3.10
# by the following command:
#
#    pip-compile
#
click==8.1.3
    # via flask
flask==2.2.2
    # via -r requirements.in
itsdangerous==2.1.2
    # via flask
jinja2==3.1.2
    # via flask
markupsafe==2.1.1
    # via
    #   jinja2
    #   werkzeug
werkzeug==2.2.2
    # via flask

Отклик команды выводит сгенерированное содержимое requirements.txt. Комментарии в начале файла напоминают нам, как сгенерировать файл. Каждая зависимость зафиксирована. По самой структуре файла мы можем понять, почему был установлен тот или иной пакет.
pip-compile решает множество проблем, не привнося серьёзной абстракции в ваш проект. Все, что нужно для базового использования - это всего лишь запомнить одну команду.
Про конвертирование существующего requirements.txt, описание процесса добавления/удаления зависимостей и обновление пакетов рассказано в документации pip-tools (https://pip-tools.readthedocs.io/en/latest/). Также в pip-tools присутствует команда pip-sync (https://github.com/jazzband/pip-tools/#example-usage-for-pip-sync) - синхронизация виртуального окружения с requirements.txt. Используйте ее с особой осторожностью, pip-sync удаляет все зависимости неупомянутые в requirements.txt.

pre-commit хук

-   repo: <https://github.com/jazzband/pip-tools>
    rev: 6.12.0
    hooks:
    -   id: pip-compile

Документация (https://pip-tools.readthedocs.io/en/latest/)
Репозиторий (https://github.com/jazzband/pip-tools)
PyPi (https://pypi.org/project/pip-tools/)
pip-sync (https://github.com/jazzband/pip-tools/#example-usage-for-pip-sync)

3. Качество кода

Под инструментами качества кода подразумеваются линтеры, средства форматирования и проверки кода. Здесь указан полный набор инструментов, которые дополнят друг друга при минимальной настройке конфигураций. Ну и конечно же, все они поместятся в наш кейс (pre-commit).

3.1 flake8

flake8 (https://github.com/PyCQA/flake8) — это инструмент, сканирующий код проекта на наличие ошибок и соответствие заданным стандартам. По сути, это полноценный линтер, использующий под капотом три других утилиты (pycodestyle, pyflakes и mccabe), который также может быть расширен с помощью пользовательских плагинов.
flake8 используется в Django, Flask и многих других open-source проектах. За время существования (flake8 появился в 2010) было создано множество различных плагинов. Про некоторые из них я расскажу в разделе «Полезные плагины».
Про настройку конфига и игнорирование ошибок можно почитать в официальной документации (https://flake8.pycqa.org/en/latest/index.html#).

pre-commit хук

Хук flake8 должен быть указан после средств форматирования кода (Black, isort, и т. д.). В противном случае линтер будет ругаться на ошибки, которые будут автоматически исправлены этими инструментами.

-   repo: <https://github.com/pycqa/flake8>
    rev: 6.0.0
		hooks:
		-   id: flake8

Полезные плагины

flake8 сам по себе неплохой линтер, но его полный потенциал можно раскрыть при использовании сторонних плагинов.
flake8-bugbear
flake8-bugbear (https://github.com/PyCQA/flake8-bugbear) — это плагин, содержащий дополнительные проверки на наличие ошибок и возможные проблемы с дизайном кода. Поддерживается разработчиками flake8.
Пример хука с добавленным плагином:

-   repo: <https://github.com/pycqa/flake8>
    rev: 6.0.0
		hooks:
		-   id: flake8
				additional_dependencies:
				-   flake8-bugbear

flake8-print
flake8-print (https://github.com/JBKahn/flake8-print) — проверка на наличие вызовов print(). Поможет предотвратить коммиты со строками отладки.

-   repo: <https://github.com/pycqa/flake8>
    rev: 6.0.0
		hooks:
		-   id: flake8
				additional_dependencies:
				-   flake8-bugbear
				-   flake8-print

Полноценный список валидированных расширений можно найти в awesome-flake8-extensions (https://github.com/DmytroLitvinov/awesome-flake8-extensions) репозитории.

Документация (https://flake8.pycqa.org/en/latest/index.html#)
Репозиторий (https://github.com/PyCQA/flake8)
flake8-bugbear (https://github.com/PyCQA/flake8-bugbear)
flake8-print (https://github.com/JBKahn/flake8-print)
awesome-flake8-extensions  (https://github.com/DmytroLitvinov/awesome-flake8-extensions)

3.2 Black

Black (https://github.com/psf/black) — это инструмент форматирующий код на основе стандарта PEP 8.
Несмотря на то, что проект вышел из беты только в этом году, Black уже используется многими известными компаниями и популярными open-source проектами: Django, Facebook, Mozilla, pandas и т. д. Кроме того, проект официально поддерживается Python Software Foundation, организацией, занимающейся разработкой Python.
Контроль над конфигурацией инструмента у вас будет минимальный. Это философия проекта. Но все же некоторые настройки можно подстроить под ваши нужды. Всю необходимую информацию для установки, интеграции и настройки Black можно найти в документации (https://black.readthedocs.io/en/stable/the_black_code_style/index.html).

pre-commit хук

В документации есть поле language_version, но в нем нет необходимости, если вы указали версию Python через опцию конфига default_language_version.

-   repo: <https://github.com/psf/black>
    rev: 22.12.0
		hooks:
		-   id: black

Документация (https://black.readthedocs.io/en/stable/the_black_code_style/index.html)
Репозиторий (https://github.com/psf/black)

3.3 isort

Black хорош как инструмент приведения кода к общему стилю. Для организации строк импорта нам понадобится другая утилита.
isort (https://github.com/PyCQA/isort) — это средство форматирования кода, предназначенное для сортировки и группировки строк импорта на основе различных критериев. Библиотека была выпущена в 2013 году. С тех пор isort стал основным инструментом сортировки импортов для большинства популярных open-source проектов.
Пример форматирования кода с помощью isort:

from __future__ import absolute_import

import os
import sys

from third_party import (lib1, lib2, lib3, lib4, lib5, lib6, lib7, lib8,
                         lib9, lib10, lib11, lib12, lib13, lib14, lib15)

from my_lib import Object, Object2, Object3

print("Hey")
print("yo")

Для интеграции инструмента вместе с black в конфигурации файла укажите профиль с одноименным названием:

[tool.isort]
profile = "black"

Установка и настройка утилиты описана в документации (https://pycqa.github.io/isort/index.html).

pre-commit хук

-   repo: <https://github.com/pycqa/isort>
    rev: 5.11.2
		hooks:
		-   id: isort

Документация (https://pycqa.github.io/isort/index.html)
Репозиторий (https://github.com/PyCQA/isort)

3.4 Mypy

Тема статической проверки типов продолжает набирать обороты в Python. Самым популярным и развитым инструментом в этой категории является Mypy (https://github.com/python/mypy) - open-source проект, разрабатываемый самим сообществом языка.
Основной стимул для использования Mypy - это нахождение багов, которые не подстать обычным линтерам. Инвестируя в аннотации и статическую типизацию, мы не только отлавливаем ошибки до их появления в runtime, но и в итоге получаем более надежный и читабельный код.
Так как наверняка ваш проект включает множество сторонних библиотек, то для эффективного использования Mypy необходимо скачать пакеты заглушек. Например, для проверки типов Django, мы можем установить заглушки django-stubs (https://pypi.org/project/django-stubs/).
В отличие от большинства других инструментов, описанных в этой статье, Mypy и проверка типов - это обширная тема, требующая хотя бы базового изучения перед тем, как она сможет принести пользу. Документация Mypy (https://mypy.readthedocs.io/en/stable/) включает руководство по началу работы, шпаргалку и справки по различным типам. Другую информацию по этой теме можно найти в awesome-python-typing (https://github.com/typeddjango/awesome-python-typing) репозитории.

pre-commit хук

-   repo: <https://github.com/pre-commit/mirrors-mypy>
    rev: v0.991
		hooks:
		-   id: mypy

Более подробно об интеграции Mypy с pre-commit в репозитории (https://github.com/pre-commit/mirrors-mypy) расширения.

Документация (https://mypy.readthedocs.io/en/stable/)
Репозиторий (https://github.com/python/mypy)
awesome-python-typing (https://github.com/typeddjango/awesome-python-typing)
mirrors-mypy (https://github.com/pre-commit/mirrors-mypy)
django-stubs (https://pypi.org/project/django-stubs/)

3.5 Ruff: замена flake8 и isort

Ruff (https://github.com/charliermarsh/ruff) — это новый, быстроразвивающийся линтер Python кода, призванный заменить flake8 и isort.
Основным преимуществом Ruff является его скорость. Ruff в 10-100 раз быстрее аналогов (Линтер написан на Rust). В сравнении с flake8, автор заявляет о практически полном совпадении с набором правил инструмента и нативной реализацией популярных плагинов (flake8-bugbear и т.д.). Также Ruff совместим с Black «из коробки».
Ruff может форматировать код. Например, он автоматически удаляет неиспользуемые импорты. Что касается сортировки и группировки строк импорта, то она практически идентична isort.
Несмотря на недавний выпуск инструмента (Август этого года), Ruff используется во многих популярных open-source проектах (FastAPI, Pydantic и т.д.).
Настройка инструмента осуществляется в pyproject.toml файле. Установка и конфигурация описана в README.md (https://github.com/charliermarsh/ruff/blob/main/README.md) проекта.
Не могу не упомянуть, что Ruff - это один из инструментов, о котором я узнал благодаря уведомлению по ключевому слову «Python» в моем Telegram-боте (https://github.com/lawxls/HackerNews-Alerts-Bot).

pre-commit хук

-   repo: <https://github.com/charliermarsh/ruff-pre-commit>
    rev: v0.0.189
		hooks:
		-   id: ruff

Документация (https://github.com/charliermarsh/ruff/blob/main/README.md)
Репозиторий (https://github.com/charliermarsh/ruffhttps://github.com/charliermarsh/ruff)
Telegram бот (https://github.com/lawxls/HackerNews-Alerts-Bot)

4. Тестирование

Тестирование - это тот этап разработки, который сообщество точно не могло оставить в стороне. В этом разделе будет рассмотрен наиболее популярный инструмент для тестирования кода, возможности которого помогут эффективно писать качественные тесты.

4.1 pytest

pytest (https://docs.pytest.org/en/7.2.x/) — это полноценный фреймворк, заменяющий unittest, стандартный модуль для написания unit-тестов.
Перечислю основные преимущества pytest:

* pytest
* значительно упрощает процесс тестирования кода. Для написания простых тестов нам не нужно ничего импортировать, достаточно использовать обычные функции с приставкой
* test_
* . Кроме того,
* pytest
* заменяет все
* self.assert
* * методы модуля
* unittest
* одним утверждением
* assert
* .
* Более информативный и читабельный вывод информации о ходе и результатах тестирования. Состояние системы, установленные плагины, детальный отчет при фейлах и т. д.
* Фикстуры вместо
* .setUp()
* и
* .tearDown()
* . Фикстуры в
* pytest -
* это функции, которые создают данные для набора тестов. Каждый тест может принимать фикстуры в качестве аргументов. Такой подход делает набор тестов более читаемым и структурированным.
* Возможность расширения фреймворка с помощью сторонних плагинов. За время существование проекта было создано более 800 плагинов.

По тестированию кода с помощью pytest написаны целые книги. Но для создания базовых тестов достаточно прочитать несколько статей из руководства (https://docs.pytest.org/en/7.2.x/getting-started.html) по началу работы.

Сайт (https://docs.pytest.org/en/7.2.x/index.html)
Effective Python Testing With Pytest (https://realpython.com/pytest-python-testing/)

5. Дебаггинг

pdb является отличным инструментом для отладки Python программ. Однако его настройка может занять некоторое время или даже оказаться невозможной (Удаленные контейнеры). PySnooper - это золотая середина между вызовами print() и полноценным, интерактивным отладчиком.

5.1 PySnooper

PySnooper (https://github.com/cool-RR/PySnooper) — это декоратор, с помощью которого можно получить полный лог функции, включая изменения локальных переменных, отработавшие строки и время их выполнения.
Установить PySnooper:

pip install pysnooper

Пример использования декоратора с рекурсивной функцией:

import pysnooper

@pysnooper.snoop()
def fact(x):
    return x if x == 1 else x * fact(x - 1)

Вывод:

Source path:... .../example.py
Starting var:.. x = 4
23:55:58.173212 call        49 def fact(x):
23:55:58.173320 line        50     return x if x == 1 else x * fact(x - 1)
    Starting var:.. x = 3
    23:55:58.173367 call        49 def fact(x):
    23:55:58.173420 line        50     return x if x == 1 else x * fact(x - 1)
        Starting var:.. x = 2
        23:55:58.173463 call        49 def fact(x):
        23:55:58.173515 line        50     return x if x == 1 else x * fact(x - 1)
            Starting var:.. x = 1
            23:55:58.173556 call        49 def fact(x):
            23:55:58.173610 line        50     return x if x == 1 else x * fact(x - 1)
            23:55:58.173643 return      50     return x if x == 1 else x * fact(x - 1)
            Return value:.. 1
            Elapsed time: 00:00:00.000146
        23:55:58.173727 return      50     return x if x == 1 else x * fact(x - 1)
        Return value:.. 2
        Elapsed time: 00:00:00.000324
    23:55:58.173807 return      50     return x if x == 1 else x * fact(x - 1)
    Return value:.. 6
    Elapsed time: 00:00:00.000499
23:55:58.173886 return      50     return x if x == 1 else x * fact(x - 1)
Return value:.. 24
Elapsed time: 00:00:00.000740

Логирование части кода можно осуществить с помощью with блока:

import pysnooper
import random

def foo():
    lst = []
    for i in range(10):
        lst.append(random.randrange(1, 1000))

    with pysnooper.snoop():
        lower = min(lst)
        upper = max(lst)
        mid = (lower + upper) / 2
        print(lower, mid, upper)

Сохранение логов в файл, логирование глобальных переменных и другую информацию по особенностям PySnooper можно найти в README.md (https://github.com/cool-RR/PySnooper/blob/master/README.md) и ADVANCED_USAGE.md (https://github.com/cool-RR/PySnooper/blob/master/ADVANCED_USAGE.md) файлах репозитория.

Репозиторий (https://github.com/cool-RR/PySnooper)
Документация (https://github.com/cool-RR/PySnooper/blob/master/README.md)
Продвинутые возможности (https://github.com/cool-RR/PySnooper/blob/master/ADVANCED_USAGE.md)

6. Терминал

Оболочка Python в том или ином виде - это незаменимый инструмент для быстрого выполнения небольших фрагментов кода и манипуляций с данными. Апгрейд этой среды непременно повысит нашу производительность. А ещe в терминале мы можем читать логи, просматривать traceback’и ошибок и получать результаты команд. Все это можно вывести в форматированном виде с помощью библиотеки Rich.

6.1 IPython

IPython (https://github.com/ipython/ipython) — это усовершенствованная оболочка Python. Инструмент содержит такие функции как «магические» команды, подсветку синтаксиса и продвинутый автокомплит.
Для использования новой оболочки нам всего лишь нужно установить пакет IPython (https://pypi.org/project/ipython/):

pip install ipython

В следующих разделах я расскажу о некоторых функциях оболочки. За вводным руководством и другой полезной информацией можно обратиться к обширной документации (https://ipython.readthedocs.io/en/stable/index.html) инструмента.

Сохранение истории вывода

Одной из полезных функций IPython является кеширование результатов вывода. Через нумерацию Out мы можем повторно использовать любой из предыдущих результатов:

In [3]: "пример"
Out[3]: 'пример'
In [4]: print(f" {_3} кеширования результатов вывода")
пример кеширования результатов вывода
In [5]: 10
Out[5]: 10
In [6]: _5 + 10
Out[6]: 20

Полезные команды

В этом разделе я указал пару команд, которые я использую постоянно. Список полезных команд не ограничивается этими двумя. Все доступные «магические» команды можно найти в разделе Built-in magic commands (https://ipython.readthedocs.io/en/stable/interactive/magics.html) официальной документации.
Для замера времени выполнения кода существует команда %timeit:

In [8]: %timeit [i for i in range(10000)]
144 µs ± 1.8 µs per loop (mean ± std. dev. of 7 runs, 10,000 loops each)

Для вывода введенной информации мы можем вызвать команду %hist:

In [9]: %hist
"пример"
print(f" {_3} кеширования результатов вывода")
5
_5 + 10
%timeit [i for i in range(10000)]
%hist

Репозиторий (https://github.com/ipython/ipython)
PyPi (https://pypi.org/project/ipython/)
Документация (https://ipython.readthedocs.io/en/stable/index.html)
Built-in magic commands (https://ipython.readthedocs.io/en/stable/interactive/magics.html)

6.2 Rich

Rich (https://github.com/Textualize/rich) — это библиотека Python для вывода форматированного текста (цвет, стиль, подсветка синтаксиса, markdown) в терминал.
Rich поддерживает все платформы и терминалы. Это сверх популярная библиотека, которая используется для форматирование вывода в большинстве проектов (В том же pip, например).
Для работы с инструментом советую ознакомиться с документацией (https://rich.readthedocs.io/en/stable/introduction.html).

Полезные возможности

Progress display
Rich может отображать настраиваемый индикатор выполнения задач (https://rich.readthedocs.io/en/stable/progress.html). По умолчанию будет отображаться описание задачи, процент выполнения, примерное оставшееся время и сам индикатор выполнения.
Rich Inspect
Кроме форматирования текста, библиотека содержит функцию (https://rich.readthedocs.io/en/stable/reference/init.html?highlight=Rich Inspect#rich.inspect) для дебаггинга объектов Python. Пример использования:

from rich import inspect
from rich.color import Color

color = Color.parse("red")
inspect(color, methods=True)


Репозиторий (https://github.com/Textualize/rich)
Документация (https://rich.readthedocs.io/en/stable/introduction.html)
Progress display (https://rich.readthedocs.io/en/stable/progress.html)
Rich Inspect (https://rich.readthedocs.io/en/stable/reference/init.html?highlight=Rich Inspect#rich.inspect)

Заключение

Практически каждый инструмент имеет свои «рабочие» альтернативы. Многие утилиты не были включены в этот список, так как я посчитал их слишком специфичными. Расскажите в комментариях, кто чем пользуется, возможно что-то упускаю и я!
На этом все. Надеюсь, статья была полезна, и вы узнали хотя бы об одном инструменте, который может быть задействован в ваших нынешних или будущих проектах.
Ссылки:
https://github.com/lawxls/HackerNews-Alerts-Bot
https://github.com/lawxls/HackerNews-Alerts-Bot
https://news.ycombinator.com/
https://github.com/pre-commit/pre-commit
https://pre-commit.com/#installation
https://github.com/pre-commit/pre-commit-hooks
https://github.com/asottile/pyupgrade
https://github.com/crate-ci/typos
https://pre-commit.com/#installation
https://github.com/pre-commit/pre-commit
https://github.com/pre-commit/pre-commit-hooks
https://github.com/asottile/pyupgradehttps://github.com/asottile/pyupgrade
https://github.com/crate-ci/typos
https://github.com/jazzband/pip-tools
https://pypi.org/project/pip-tools/
https://pip-tools.readthedocs.io/en/latest/
https://github.com/jazzband/pip-tools/#example-usage-for-pip-sync
https://pip-tools.readthedocs.io/en/latest/
https://github.com/jazzband/pip-tools
https://pypi.org/project/pip-tools/
https://github.com/jazzband/pip-tools/#example-usage-for-pip-sync
https://github.com/PyCQA/flake8
https://flake8.pycqa.org/en/latest/index.html#
https://github.com/PyCQA/flake8-bugbear
https://github.com/JBKahn/flake8-print
https://github.com/DmytroLitvinov/awesome-flake8-extensions
https://flake8.pycqa.org/en/latest/index.html#
https://github.com/PyCQA/flake8
https://github.com/PyCQA/flake8-bugbear
https://github.com/JBKahn/flake8-print
https://github.com/DmytroLitvinov/awesome-flake8-extensions
https://github.com/psf/black
https://black.readthedocs.io/en/stable/the_black_code_style/index.html
https://black.readthedocs.io/en/stable/the_black_code_style/index.html
https://github.com/psf/black
https://github.com/PyCQA/isort
https://pycqa.github.io/isort/index.html
https://pycqa.github.io/isort/index.html
https://github.com/PyCQA/isort
https://github.com/python/mypy
https://pypi.org/project/django-stubs/
https://mypy.readthedocs.io/en/stable/
https://github.com/typeddjango/awesome-python-typing
https://github.com/pre-commit/mirrors-mypy
https://mypy.readthedocs.io/en/stable/
https://github.com/python/mypy
https://github.com/typeddjango/awesome-python-typing
https://github.com/pre-commit/mirrors-mypy
https://pypi.org/project/django-stubs/
https://github.com/charliermarsh/ruff
https://github.com/charliermarsh/ruff/blob/main/README.md
https://github.com/lawxls/HackerNews-Alerts-Bot
https://github.com/charliermarsh/ruff/blob/main/README.md
https://github.com/charliermarsh/ruffhttps://github.com/charliermarsh/ruff
https://github.com/lawxls/HackerNews-Alerts-Bot
https://docs.pytest.org/en/7.2.x/
https://docs.pytest.org/en/7.2.x/getting-started.html
https://docs.pytest.org/en/7.2.x/index.html
https://realpython.com/pytest-python-testing/
https://github.com/cool-RR/PySnooper
https://github.com/cool-RR/PySnooper/blob/master/README.md
https://github.com/cool-RR/PySnooper/blob/master/ADVANCED_USAGE.md
https://github.com/cool-RR/PySnooper
https://github.com/cool-RR/PySnooper/blob/master/README.md
https://github.com/cool-RR/PySnooper/blob/master/ADVANCED_USAGE.md
https://github.com/ipython/ipython
https://pypi.org/project/ipython/
https://ipython.readthedocs.io/en/stable/index.html
https://ipython.readthedocs.io/en/stable/interactive/magics.html
https://github.com/ipython/ipython
https://pypi.org/project/ipython/
https://ipython.readthedocs.io/en/stable/index.html
https://ipython.readthedocs.io/en/stable/interactive/magics.html
https://github.com/Textualize/rich
https://rich.readthedocs.io/en/stable/introduction.html
https://rich.readthedocs.io/en/stable/progress.html
https://rich.readthedocs.io/en/stable/reference/init.html?highlight=Rich Inspect#rich.inspect
https://github.com/Textualize/rich
https://rich.readthedocs.io/en/stable/introduction.html
https://rich.readthedocs.io/en/stable/progress.html
https://rich.readthedocs.io/en/stable/reference/init.html?highlight=Rich Inspect#rich.inspect
